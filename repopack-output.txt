================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-10-20T17:35:05.315Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
hooks/useChapter.ts
hooks/useEPUB.ts
model/booksApiSlice.ts
model/epubUtils.ts
model/types.ts
ui/BookReader.tsx
ui/ChaptersPopup.tsx

================================================================
Repository Files
================================================================

================
File: hooks/useChapter.ts
================
// src/features/bookReader/hooks/useChapter.ts
import { useState, useEffect } from 'react';
import JSZip from 'jszip';
import DOMPurify from 'dompurify';
import { getFullImagePath } from '../model/epubUtils';

interface UseChapterProps {
    bookFile: Blob;
    href: string;
    images: Record<string, string>;
}

//! Загрузка содержимого текущей главы
const useChapter = ({ bookFile, href, images }: UseChapterProps) => {
    const [content, setContent] = useState<string | null>(null);
    const [error, setError] = useState<string | null>(null);

    useEffect(() => {
        const loadChapter = async () => {
            try {
                const zip = await JSZip.loadAsync(bookFile);
                const baseHref = href.split('#')[0];
                let chapterFile = zip.file(`OPS/${baseHref}`);
                if (!chapterFile) {
                    const availableFiles = Object.keys(zip.files);
                    const similarFile = availableFiles.find((file) => file.toLowerCase() === baseHref.toLowerCase());
                    if (similarFile) {
                        chapterFile = zip.file(similarFile);
                        console.warn(`Найден файл с похожим именем: ${similarFile}`);
                    } else {
                        throw new Error(`Файл главы не найден: ${baseHref}`);
                    }
                }

                let contentFile = await chapterFile.async('string');
                contentFile = contentFile.replace(/<\?xml.*?\?>\s*/g, '');

                const parser = new DOMParser();
                const doc = parser.parseFromString(contentFile, 'application/xhtml+xml');
                const body = doc.body;

                if (body) {
                    const imagesInContent = body.querySelectorAll('img, image');
                    imagesInContent.forEach((imgElement) => {
                        if (imgElement.tagName.toLowerCase() === 'img') {
                            const src = imgElement.getAttribute('src');
                            if (src) {
                                const imagePath = getFullImagePath(baseHref, src);
                                const imageUri = images[imagePath] || images[src];
                                if (imageUri) {
                                    imgElement.setAttribute('src', imageUri);
                                } else {
                                    console.warn(`Изображение не найдено: ${src}`);
                                }
                            }
                        } else if (imgElement.tagName.toLowerCase() === 'image') {
                            const hrefAttr = imgElement.getAttributeNS('http://www.w3.org/1999/xlink', 'href');
                            if (hrefAttr) {
                                const imagePath = getFullImagePath(baseHref, hrefAttr);
                                const imageUri = images[imagePath] || images[hrefAttr];
                                if (imageUri) {
                                    imgElement.setAttributeNS('http://www.w3.org/1999/xlink', 'href', imageUri);
                                } else {
                                    console.warn(`Изображение не найдено: ${hrefAttr}`);
                                }
                            }
                        }
                    });

                    const serializer = new XMLSerializer();
                    let bodyContent = serializer.serializeToString(body);
                    bodyContent = DOMPurify.sanitize(bodyContent);
                    setContent(bodyContent);
                } else {
                    throw new Error('Тег <body> не найден в содержимом главы.');
                }
            } catch (err) {
                console.error('Ошибка при загрузке содержимого главы:', err);
                setError(err.message);
            }
        };

        loadChapter();
    }, [href, bookFile, images]);

    return { content, error };
};

export default useChapter;

================
File: hooks/useEPUB.ts
================
// src/features/bookReader/hooks/useEPUB.ts
import { useState, useEffect } from 'react';
import JSZip from 'jszip';
import DOMPurify from 'dompurify';
import { parseNavPoints, getFullImagePath } from '../model/epubUtils'; // Вынесите функции в shared/utils
import { Chapter } from '../model/types';

//! Загрузка EPUB и парсинг TOC  на главы
const useEPUB = (bookFile: Blob | null) => {
    const [chapters, setChapters] = useState<Chapter[]>([]);
    const [cssContent, setCssContent] = useState<string>('');
    const [images, setImages] = useState<Record<string, string>>({});
    const [error, setError] = useState<string | null>(null);

    useEffect(() => {
        const loadEpub = async () => {
            if (bookFile) {
                try {
                    const zip = await JSZip.loadAsync(bookFile);

                    // Загрузка TOC
                    const tocFile = zip.file(/toc\.ncx$/i)[0];
                    if (!tocFile) throw new Error('toc.ncx не найден');

                    const tocContent = await tocFile.async('string');
                    const parser = new DOMParser();
                    const tocDoc = parser.parseFromString(tocContent, 'application/xml');
                    const rootNavPoints = tocDoc.querySelectorAll('navMap > navPoint');
                    const newChapters = parseNavPoints(rootNavPoints);
                    setChapters(newChapters);

                    // Загрузка CSS
                    const cssFiles = Array.from(zip.file(/.*\.css$/i));
                    const cssContents = await Promise.all(cssFiles.map((file) => file.async('string')));
                    setCssContent(cssContents.join('\n'));

                    // Загрузка изображений
                    const imageFiles = Array.from(zip.file(/\.(png|jpg|jpeg|gif|svg)$/i));
                    const imageMap: Record<string, string> = {};
                    await Promise.all(
                        imageFiles.map(async (file) => {
                            const data = await file.async('base64');
                            const extensionMatch = file.name.match(/\.(png|jpg|jpeg|gif|svg)$/i);
                            const extension = extensionMatch ? extensionMatch[1].toLowerCase() : 'png';
                            const mimeType = extension === 'svg' ? 'image/svg+xml' : `image/${extension === 'jpg' ? 'jpeg' : extension}`;
                            const dataUri = `data:${mimeType};base64,${data}`;
                            imageMap[file.name] = dataUri;
                        })
                    );
                    setImages(imageMap);
                } catch (err) {
                    console.error('Ошибка при загрузке EPUB:', err);
                    setError(err.message);
                }
            }
        };

        loadEpub();
    }, [bookFile]);

    return { chapters, cssContent, images, error };
};

export default useEPUB;

================
File: model/booksApiSlice.ts
================
import { api } from '@/app/api/apiSlice';
import JSZip from 'jszip';

export interface Book {
    _id: string;
    filePath: string;
    title?: string;
    creator?: string;
    description?: string;
}

export interface ParsedBook extends Omit<Book, '_id'> {
    title: string;
    creator: string;
    description: string;
    content: ArrayBuffer;
}

export const booksApi = api.injectEndpoints({
    endpoints: (builder) => ({
        getBooks: builder.query<Book[], void>({
            query: () => 'books',
            providesTags: ['Books'],
        }),
        getBookById: builder.query<ArrayBuffer, string>({
            query: (id) => ({
                url: `http://localhost:3500/api/books/${id}`,
                responseHandler: (response) => response.arrayBuffer(), // Обработка ответа как ArrayBuffer
            }),
        }),

        getBookContent: builder.query<ParsedBook, string>({
            query: (filePath) => ({
                url: 'http://localhost:3500' + filePath,
                responseHandler: (response) => response.arrayBuffer(),
            }),
            transformResponse: async (content: ArrayBuffer, _, filePath) => {
                const zip = await JSZip.loadAsync(content);
                const metadataFile = zip.file('OEBPS/content.opf') || zip.file('content.opf');
                const metadataContent = metadataFile ? await metadataFile.async('text') : '';

                const parser = new DOMParser();
                const metadataDoc = parser.parseFromString(metadataContent, 'application/xml');
                const title = metadataDoc.querySelector('title')?.textContent || 'Unknown Title';
                const creator = metadataDoc.querySelector('creator')?.textContent || 'Unknown Author';
                const description = metadataDoc.querySelector('description')?.textContent || 'No description available';

                return {
                    title,
                    creator,
                    description,
                    content,
                    filePath,
                };
            },
        }),
        uploadBook: builder.mutation<void, FormData>({
            query: (formData) => ({
                url: 'books',
                method: 'POST',
                body: formData,
            }),
            invalidatesTags: ['Books'],
        }),
        deleteBook: builder.mutation<void, string>({
            query: (id) => ({
                url: `books/${id}`,
                method: 'DELETE',
            }),
            invalidatesTags: ['Books'],
        }),
    }),
});

export const { useGetBooksQuery, useUploadBookMutation, useDeleteBookMutation, useGetBookByIdQuery, useGetBookContentQuery } = booksApi;

================
File: model/epubUtils.ts
================
// src/shared/utils/epubUtils.ts
import { Chapter } from '../model/types';

export const parseNavPoints = (navPoints: NodeListOf<Element>, currentLevel: number = 1): Chapter[] => {
    const chapters: Chapter[] = [];

    navPoints.forEach((navPoint) => {
        const label = navPoint.querySelector('navLabel > text')?.textContent || 'Глава';
        const href = navPoint.querySelector('content')?.getAttribute('src') || '';

        const chapter: Chapter = {
            label,
            href,
            cfi: '',
            level: currentLevel,
            children: [],
        };

        const childNavPoints = navPoint.querySelectorAll(':scope > navPoint');
        if (childNavPoints.length > 0) {
            chapter.children = parseNavPoints(childNavPoints, currentLevel + 1);
        }

        chapters.push(chapter);
    });

    return chapters;
};

export const getFullImagePath = (baseHref: string, src: string): string => {
    if (src.startsWith('/')) {
        return src.substring(1);
    } else {
        const chapterPath = baseHref.substring(0, baseHref.lastIndexOf('/') + 1);
        return chapterPath + src;
    }
};

================
File: model/types.ts
================
export interface Chapter {
    label: string;
    href: string;
    cfi: string; // CFI можно вычислить позже, если потребуется
    level: number; // Представляет уровень вложенности
    children?: Chapter[];
}

================
File: ui/BookReader.tsx
================
import React, { useEffect, useState } from 'react';
import { useParams } from 'react-router-dom';
import { useGetBookByIdQuery } from '../model/booksApiSlice';
import { Loader2 } from 'lucide-react';
import htmlReactParser from 'html-react-parser';

import { ChaptersPopup } from './ChaptersPopup';
import useChapter from '../hooks/useChapter';
import useEPUB from '../hooks/useEPUB';

const BookReader: React.FC = () => {
    const { id } = useParams<{ id: string }>();
    const [currentChapter, setCurrentChapter] = useState<string | null>(null);

    const { data: bookFile, isLoading: isLoadingContent, error } = useGetBookByIdQuery(id);
    const { chapters, cssContent, images, error: epubError } = useEPUB(bookFile);

    // Установить первую главу после загрузки оглавления
    useEffect(() => {
        if (chapters.length > 0 && !currentChapter) {
            setCurrentChapter(chapters[0].href);
        }
    }, [chapters, currentChapter]);

    const { content } = useChapter({
        bookFile,
        href: currentChapter,
        images,
    });

    if (isLoadingContent) {
        return <Loader2 />;
    }

    if (error) {
        return <div>Error loading book: {error?.message}</div>;
    }

    return (
        <div className="book-reader" style={{ position: 'relative' }}>
            {/* Внедрение CSS-стилей */}
            {cssContent && <style>{cssContent}</style>}

            {/* Всплывающее окно с оглавлением */}
            <ChaptersPopup mockChapters={chapters} currentChapter={currentChapter} setCurrentChapter={setCurrentChapter} />

            {/* Основное содержимое книги */}
            <div className="chapter-content">{content ? htmlReactParser(content) : <div>Выберите главу для чтения.</div>}</div>
        </div>
    );
};

export default BookReader;

================
File: ui/ChaptersPopup.tsx
================
import { useState } from 'react';
import { ChevronRight, ChevronDown, AlignLeft } from 'lucide-react';
import { Popover, PopoverContent, PopoverTrigger } from '@/shared/ui/components/ui/popover';

interface Chapter {
    label: string;
    href: string;
    cfi: string;
    level: number;
    children?: Chapter[];
}

interface ChaptersPopupProps {
    mockChapters: Chapter[];
    currentChapter: string; // Рекомендуется уточнить тип
    setCurrentChapter: (href: string) => void; // Рекомендуется уточнить тип
}

export const ChaptersPopup = ({ mockChapters, currentChapter, setCurrentChapter }: ChaptersPopupProps) => {
    const [expandedChapters, setExpandedChapters] = useState<Set<string>>(new Set());

    const toggleChapter = (href: string) => {
        setExpandedChapters((prev) => {
            const newSet = new Set(prev);
            if (newSet.has(href)) {
                newSet.delete(href);
            } else {
                newSet.add(href);
            }
            return newSet;
        });
    };

    const renderChapter = (chapter: Chapter, parentExpanded: boolean = true) => {
        const isExpanded = expandedChapters.has(chapter.href);
        const hasChildren = chapter.children && chapter.children.length > 0;

        if (!parentExpanded && chapter.level !== 1) return null;

        return (
            <div key={chapter.href} className="w-full">
                <div
                    onClick={() => setCurrentChapter(chapter.href)}
                    className={`flex items-center p-2 cursor-pointer hover:bg-slate-100 ${currentChapter === chapter.href ? 'bg-slate-200' : ''}`}
                    style={{
                        paddingLeft: `${chapter.level * 12}px`,
                    }}
                >
                    {hasChildren ? (
                        <button
                            onClick={(e) => {
                                e.stopPropagation();
                                toggleChapter(chapter.href);
                            }}
                            className="mr-2 flex items-center justify-center w-4 h-4 focus:outline-none"
                            aria-expanded={isExpanded}
                            aria-label={isExpanded ? 'Свернуть раздел' : 'Развернуть раздел'}
                        >
                            {isExpanded ? <ChevronDown className="w-4 h-4 flex-shrink-0" /> : <ChevronRight className="w-4 h-4 flex-shrink-0" />}
                        </button>
                    ) : (
                        // Заполнитель для выравнивания
                        <span className="mr-2 w-4 h-4 inline-block"></span>
                    )}
                    <span className="truncate">{chapter.label}</span>
                </div>
                {isExpanded && hasChildren && <div>{chapter.children!.map((subChapter) => renderChapter(subChapter, isExpanded))}</div>}
            </div>
        );
    };

    return (
        <Popover>
            <PopoverTrigger>
                <AlignLeft className="ml-4" />
            </PopoverTrigger>
            <PopoverContent className="w-[400px] p-0">
                <div className="h-[400px] overflow-y-auto overflow-x-hidden hide-scrollbar">
                    {mockChapters.map((chapter) => renderChapter(chapter))}
                </div>
            </PopoverContent>
        </Popover>
    );
};
