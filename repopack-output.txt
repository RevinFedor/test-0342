================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-10-22T12:08:07.094Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
hooks/useChapter.ts
hooks/useChapterDuplicate.ts
hooks/useEPUB.ts
model/booksApiSlice.ts
model/types.ts
model/utils.ts
ui/BookReader.tsx
ui/ChaptersPopup.tsx
ui/PagedText.tsx

================================================================
Repository Files
================================================================

================
File: hooks/useChapter.ts
================
// src/features/bookReader/hooks/useChapter.ts
import { useState, useEffect } from 'react';
import JSZip from 'jszip';
import DOMPurify from 'dompurify';
import { getFullImagePath } from '../model/utils';

interface UseChapterProps {
    bookFile: ArrayBuffer | null; // Changed from Blob to ArrayBuffer
    href: string;
    images: Record<string, string>;
}

const useChapter = ({ bookFile, href, images }: UseChapterProps) => {
    const [content, setContent] = useState<string | null>(null);
    const [error, setError] = useState<string | null>(null);

    useEffect(() => {
        if (!bookFile) {
            return;
        }
        const loadChapter = async () => {
            try {
                console.log('Loading chapter with href:', href);
                const zip = await JSZip.loadAsync(bookFile);
                const baseHref = href.split('#')[0];
                let chapterFile = zip.file(`OPS/${baseHref}`);
                if (!chapterFile) {
                    const availableFiles = Object.keys(zip.files);
                    const similarFile = availableFiles.find((file) => file.toLowerCase() === baseHref.toLowerCase());
                    if (similarFile) {
                        chapterFile = zip.file(similarFile);
                        console.warn(`Found a similar file name: ${similarFile}`);
                    } else {
                        throw new Error(`Chapter file not found: ${baseHref}`);
                    }
                }

                let contentFile = await chapterFile.async('string');
                contentFile = contentFile.replace(/<\?xml.*?\?>\s*/g, '');

                const parser = new DOMParser();
                const doc = parser.parseFromString(contentFile, 'application/xhtml+xml');
                const body = doc.body;

                if (body) {
                    const imagesInContent = body.querySelectorAll('img, image');
                    imagesInContent.forEach((imgElement) => {
                        const src = imgElement.getAttribute('src') || imgElement.getAttributeNS('http://www.w3.org/1999/xlink', 'href');
                        if (src) {
                            const imagePath = getFullImagePath(baseHref, src);
                            const imageUri = images[imagePath] || images[src];

                            // Проверяем, является ли элемент HTML-картинкой (<img>) или SVG-картинкой (<image>),
                            // и устанавливаем правильный атрибут для источника изображения (src для HTML и href для SVG).
                            if (imageUri) {
                                if (imgElement instanceof HTMLImageElement || imgElement instanceof SVGImageElement) {
                                    if (imgElement instanceof HTMLImageElement) {
                                        imgElement.setAttribute('src', imageUri);
                                    } else {
                                        imgElement.setAttributeNS('http://www.w3.org/1999/xlink', 'href', imageUri);
                                    }

                                    imgElement.style.display = 'block';
                                    imgElement.style.marginLeft = 'auto';
                                    imgElement.style.marginRight = 'auto';
                                    imgElement.style.maxWidth = '100%';
                                    imgElement.style.height = 'auto';
                                }
                            } else {
                                console.warn(`Image not found: ${src}`);
                            }
                        }
                    });

                    const serializer = new XMLSerializer();
                    let bodyContent = serializer.serializeToString(body);
                    bodyContent = DOMPurify.sanitize(bodyContent);
                    setContent(bodyContent);
                } else {
                    throw new Error('The <body> tag was not found in the chapter content.');
                }
            } catch (err: any) {
                console.error('Error loading chapter content:', err);
                setError(err.message);
            }
        };

        if (bookFile && href) {
            loadChapter();
        }
    }, [href, bookFile, images]);

    return { content, error };
};

export default useChapter;

================
File: hooks/useChapterDuplicate.ts
================
// src/features/bookReader/hooks/useChapterDuplicate.ts

import { useState, useEffect } from 'react';
import { loadChapterContent, computeHash, flattenChapters } from '../model/utils';
import { Chapter } from '../model/types';


/**
 * Интерфейс для входных параметров хука useChapterDuplicate.
 */
interface useChapterDuplicateProps {
    bookFile: ArrayBuffer | null;
    chapters: Chapter[];
}

/**
 * Интерфейс для выходных данных хука useChapterDuplicate.
 */
interface useChapterDuplicateReturn {
    duplicates: Record<string, string[]>; // хеш и список href
    loading: boolean;
    error: string | null;
}

/**
 * Хук useChapterDuplicate находит дублирующиеся главы на основе содержимого.
 * @param bookFile - EPUB файл как ArrayBuffer
 * @param chapters - список глав
 * @returns { duplicates, loading, error }
 */
const useChapterDuplicate = ({ bookFile, chapters }: useChapterDuplicateProps): useChapterDuplicateReturn => {
    const [duplicates, setDuplicates] = useState<Record<string, string[]>>({});
    const [loading, setLoading] = useState<boolean>(false);
    const [error, setError] = useState<string | null>(null);

    useEffect(() => {
        const findDuplicates = async () => {
            if (!bookFile || chapters.length === 0) {
                setError('EPUB файл или список глав не предоставлены.');
                return;
            }

            setLoading(true);
            setError(null);

            try {
                const flatChapters = flattenChapters(chapters);
                const hashMap: Record<string, string[]> = {};

                for (const chapter of flatChapters) {
                    const href = chapter.href;
                    const content = await loadChapterContent(bookFile, href);
                    if (content) {
                        const hash = await computeHash(content);
                        if (hashMap[hash]) {
                            hashMap[hash].push(href);
                        } else {
                            hashMap[hash] = [href];
                        }
                    } else {
                        console.warn(`Содержимое главы не загружено: ${href}`);
                    }
                }

                // Фильтруем только те хеши, у которых более одной главы
                const duplicatesFound: Record<string, string[]> = {};
                Object.entries(hashMap).forEach(([hash, hrefs]) => {
                    if (hrefs.length > 1) {
                        duplicatesFound[hash] = hrefs;
                    }
                });

                setDuplicates(duplicatesFound);

                // if (Object.keys(duplicatesFound).length === 0) {
                //     console.log('Дублирующиеся главы не найдены.');
                // } else {
                //     console.log('Найдены дублирующиеся главы:', duplicatesFound);
                // }
            } catch (err: any) {
                console.error('Ошибка при поиске дублирующихся глав:', err);
                setError(err.message || 'Неизвестная ошибка');
            } finally {
                setLoading(false);
            }
        };

        findDuplicates();
    }, [bookFile, chapters]);

    return { duplicates, loading, error };
};

export default useChapterDuplicate;

================
File: hooks/useEPUB.ts
================
// src/features/bookReader/hooks/useEPUB.ts
import { useState, useEffect } from 'react';
import JSZip from 'jszip';
import DOMPurify from 'dompurify';
import { parseNavPoints, getFullImagePath } from '../model/utils'; // Вынесите функции в shared/utils
import { Chapter } from '../model/types';

const useEPUB = (bookFile: Blob | null) => {
    const [chapters, setChapters] = useState<Chapter[]>([]);
    const [cssContent, setCssContent] = useState<string>('');
    const [images, setImages] = useState<Record<string, string>>({});
    const [error, setError] = useState<string | null>(null);

    useEffect(() => {
        const loadEpub = async () => {
            if (bookFile) {
                try {
                    const zip = await JSZip.loadAsync(bookFile);

                    // Загрузка TOC
                    const tocFile = zip.file(/toc\.ncx$/i)[0];
                    if (!tocFile) throw new Error('toc.ncx не найден');

                    const tocContent = await tocFile.async('string');
                    const parser = new DOMParser();
                    const tocDoc = parser.parseFromString(tocContent, 'application/xml');
                    const rootNavPoints = tocDoc.querySelectorAll('navMap > navPoint');
                    const newChapters = parseNavPoints(rootNavPoints);
                    setChapters(newChapters);

                    // Загрузка CSS
                    const cssFiles = Array.from(zip.file(/.*\.css$/i));
                    const cssContents = await Promise.all(cssFiles.map((file) => file.async('string')));
                    setCssContent(cssContents.join('\n'));

                    // Загрузка изображений
                    const imageFiles = Array.from(zip.file(/\.(png|jpg|jpeg|gif|svg)$/i));
                    const imageMap: Record<string, string> = {};
                    await Promise.all(
                        imageFiles.map(async (file) => {
                            const data = await file.async('base64');
                            const extensionMatch = file.name.match(/\.(png|jpg|jpeg|gif|svg)$/i);
                            const extension = extensionMatch ? extensionMatch[1].toLowerCase() : 'png';
                            const mimeType = extension === 'svg' ? 'image/svg+xml' : `image/${extension === 'jpg' ? 'jpeg' : extension}`;
                            const dataUri = `data:${mimeType};base64,${data}`;
                            imageMap[file.name] = dataUri;
                        })
                    );

                    setImages(imageMap);
                } catch (err) {
                    console.error('Ошибка при загрузке EPUB:', err);
                    setError(err.message);
                }
            }
        };

        loadEpub();
    }, [bookFile]);

    return { chapters, cssContent, images, error };
};

export default useEPUB;

================
File: model/booksApiSlice.ts
================
import { api } from '@/app/api/apiSlice';
import JSZip from 'jszip';

export interface Book {
    _id: string;
    filePath: string;
    title?: string;
    creator?: string;
    description?: string;
}

export interface ParsedBook extends Omit<Book, '_id'> {
    title: string;
    creator: string;
    description: string;
    content: ArrayBuffer;
}

export const booksApi = api.injectEndpoints({
    endpoints: (builder) => ({
        getBooks: builder.query<Book[], void>({
            query: () => 'books',
            providesTags: ['Books'],
        }),
        getBookById: builder.query<ArrayBuffer, string>({
            query: (id) => ({
                url: `http://localhost:3500/api/books/${id}`,
                responseHandler: (response) => response.arrayBuffer(), // Обработка ответа как ArrayBuffer
            }),
        }),

        getBookContent: builder.query<ParsedBook, string>({
            query: (filePath) => ({
                url: 'http://localhost:3500' + filePath,
                responseHandler: (response) => response.arrayBuffer(),
            }),
            transformResponse: async (content: ArrayBuffer, _, filePath) => {
                const zip = await JSZip.loadAsync(content);
                const metadataFile = zip.file('OEBPS/content.opf') || zip.file('content.opf');
                const metadataContent = metadataFile ? await metadataFile.async('text') : '';

                const parser = new DOMParser();
                const metadataDoc = parser.parseFromString(metadataContent, 'application/xml');
                const title = metadataDoc.querySelector('title')?.textContent || 'Unknown Title';
                const creator = metadataDoc.querySelector('creator')?.textContent || 'Unknown Author';
                const description = metadataDoc.querySelector('description')?.textContent || 'No description available';

                return {
                    title,
                    creator,
                    description,
                    content,
                    filePath,
                };
            },
        }),
        uploadBook: builder.mutation<void, FormData>({
            query: (formData) => ({
                url: 'books',
                method: 'POST',
                body: formData,
            }),
            invalidatesTags: ['Books'],
        }),
        deleteBook: builder.mutation<void, string>({
            query: (id) => ({
                url: `books/${id}`,
                method: 'DELETE',
            }),
            invalidatesTags: ['Books'],
        }),
    }),
});

export const { useGetBooksQuery, useUploadBookMutation, useDeleteBookMutation, useGetBookByIdQuery, useGetBookContentQuery } = booksApi;

================
File: model/types.ts
================
export interface Chapter {
    label: string;
    href: string;
    cfi: string; // CFI можно вычислить позже, если потребуется
    level: number; // Представляет уровень вложенности
    children?: Chapter[];
    
}

================
File: model/utils.ts
================
// src/shared/utils/epubUtils.ts
import JSZip from 'jszip';
import { Chapter } from './types';
import DOMPurify from 'dompurify';

export const parseNavPoints = (navPoints: NodeListOf<Element>, currentLevel: number = 1): Chapter[] => {
    const chapters: Chapter[] = [];

    navPoints.forEach((navPoint) => {
        const label = navPoint.querySelector('navLabel > text')?.textContent || 'Глава';
        const href = navPoint.querySelector('content')?.getAttribute('src') || '';

        const chapter: Chapter = {
            label,
            href,
            cfi: '',
            level: currentLevel,
            children: [],
        };

        const childNavPoints = navPoint.querySelectorAll(':scope > navPoint');
        if (childNavPoints.length > 0) {
            chapter.children = parseNavPoints(childNavPoints, currentLevel + 1);
        }

        chapters.push(chapter);
    });

    return chapters;
};

export const getFullImagePath = (baseHref: string, src: string): string => {
    // If the src is already an absolute path like 'OPS/images/...'
    if (src.startsWith('OPS/')) {
        return src;
    }

    // If the src is relative, ensure that 'OPS/' is prepended if it's missing
    const chapterPath = baseHref.substring(0, baseHref.lastIndexOf('/') + 1);
    const fullPath = chapterPath + src;

    if (!fullPath.startsWith('OPS/')) {
        return 'OPS/' + fullPath;
    }

    return fullPath;
};

/**
 * Хелпер-функция для разворачивания иерархии глав.
 * @param chapters - список глав
 * @returns плоский список глав
 */
export const flattenChapters = (chapters: Chapter[]): Chapter[] => {
    const flat: Chapter[] = [];
    const traverse = (chapterList: Chapter[]) => {
        chapterList.forEach((chapter) => {
            flat.push(chapter);
            if (chapter.children && chapter.children.length > 0) {
                traverse(chapter.children);
            }
        });
    };
    traverse(chapters);
    return flat;
};

//! Функция для получения всех родительских глав до третьего или четвертого уровня
export const getParentChapters = (chapters: Chapter[], href: string): Chapter[] => {
    const parents: Chapter[] = [];

    const findChapter = (chapterList: Chapter[], currentHref: string, ancestors: Chapter[] = []): boolean => {
        for (const chapter of chapterList) {
            const newAncestors = [...ancestors, chapter];
            if (chapter.href === currentHref) {
                // Добавляем найденных родителей
                parents.push(...newAncestors);
                return true;
            }

            // Если у главы есть вложенные, ищем в них
            if (chapter.children && chapter.children.length > 0) {
                const found = findChapter(chapter.children, currentHref, newAncestors);
                if (found) {
                    return true;
                }
            }
        }
        return false;
    };

    findChapter(chapters, href);
    return parents;
};

//! ++++++++++++++++++++++
/**
 * Получает базовый href, удаляя фрагмент.
 * @param href - полный href с фрагментом
 * @returns базовый href без фрагмента
 */
export const getBaseHref = (href: string): string => {
    const [baseHref] = href.split('#');
    return baseHref;
};

/**
 * Загружает содержимое главы по href.
 * @param bookFile - EPUB файл как ArrayBuffer
 * @param href - href главы
 * @returns содержимое главы как строка или null в случае ошибки
 */
export const loadChapterContent = async (bookFile: ArrayBuffer, href: string): Promise<string | null> => {
    try {
        const zip = await JSZip.loadAsync(bookFile);
        const baseHref = getBaseHref(href);
        let chapterFile = zip.file(`OPS/${baseHref}`);

        if (!chapterFile) {
            const availableFiles = Object.keys(zip.files);
            const similarFile = availableFiles.find((file) => file.toLowerCase() === baseHref.toLowerCase());
            if (similarFile) {
                chapterFile = zip.file(similarFile);
            } else {
                return null;
            }
        }

        let chapterContent = await chapterFile.async('string');
        // Удаляем XML декларацию, если она есть
        chapterContent = chapterContent.replace(/<\?xml.*?\?>\s*/g, '');

        // Очищаем содержимое с помощью DOMPurify
        const parser = new DOMParser();
        const doc = parser.parseFromString(chapterContent, 'application/xhtml+xml');
        const body = doc.body;

        if (!body) {
            console.warn('Тег <body> не найден в содержимом главы.');
            return null;
        }

        // Сериализуем содержимое <body>
        const serializer = new XMLSerializer();
        let sanitizedContent = serializer.serializeToString(body);
        sanitizedContent = DOMPurify.sanitize(sanitizedContent);
        return sanitizedContent;
    } catch (err) {
        console.error('Ошибка при загрузке содержимого главы:', err);
        return null;
    }
};

/**
 * Вычисляет SHA-256 хеш для заданной строки.
 * @param content - содержимое главы
 * @returns хеш в формате hex
 */
export const computeHash = async (content: string): Promise<string> => {
    const encoder = new TextEncoder();
    const data = encoder.encode(content);
    const hashBuffer = await crypto.subtle.digest('SHA-256', data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map((b) => b.toString(16).padStart(2, '0')).join('');
    return hashHex;
};

================
File: ui/BookReader.tsx
================
import React, { useEffect, useState } from 'react';
import { useParams } from 'react-router-dom';
import { useGetBookByIdQuery } from '../model/booksApiSlice';
import { ArrowLeft, ArrowRight, Loader2 } from 'lucide-react';

import { ChaptersPopup } from './ChaptersPopup';
import useChapter from '../hooks/useChapter';
import useEPUB from '../hooks/useEPUB';
import PagedText from './PagedText';
import { flattenChapters, getParentChapters } from '../model/utils';
import useChapterDuplicate from '../hooks/useChapterDuplicate';

const BookReader: React.FC = () => {
    const { id } = useParams<{ id: string }>();
    const [currentChapter, setCurrentChapter] = useState<string>(null);
    const [isScrollingInPopup, setIsScrollingInPopup] = useState(false); // Новый state для отслеживания скролла внутри оглавления

    const { data: bookFile, isLoading: isLoadingContent, error } = useGetBookByIdQuery(id);
    const { chapters, cssContent, images } = useEPUB(bookFile);

    useEffect(() => {
        if (chapters.length > 0 && !currentChapter) {
            setCurrentChapter(chapters[0].href);
        }
    }, [chapters, currentChapter]);

    const { content } = useChapter({
        bookFile,
        href: currentChapter,
        images,
    });

    //! Используем хук для поиска дублирующихся глав
    const {
        duplicates,
        loading: isLoadingDuplicates,
        error: duplicatesError,
    } = useChapterDuplicate({
        bookFile,
        chapters,
    });



    //! настройка скролла для popup оглавления
    const handleWheel = (event: WheelEvent) => {
        if (!isScrollingInPopup) {
            if (event.deltaY < 0) {
            } else if (event.deltaY > 0) {
            }
        }
    };

    useEffect(() => {
        window.addEventListener('wheel', handleWheel);

        return () => {
            window.removeEventListener('wheel', handleWheel);
        };
    }, [isScrollingInPopup]);

    //!логика переключения глав

    // Логика переключения глав с учётом вложенности
    const handleNext = () => {
        const flatChapters = flattenChapters(chapters); // Все главы в одном массиве
        const currentChapterIndex = flatChapters.findIndex((ch) => ch.href === currentChapter);

        if (currentChapterIndex !== -1 && currentChapterIndex < flatChapters.length - 1) {
            setCurrentChapter(flatChapters[currentChapterIndex + 1].href);
        }
    };

    const handlePrev = () => {
        const flatChapters = flattenChapters(chapters); // Все главы в одном массиве
        const currentChapterIndex = flatChapters.findIndex((ch) => ch.href === currentChapter);

        if (currentChapterIndex > 0) {
            setCurrentChapter(flatChapters[currentChapterIndex - 1].href);
        }
    };

    const parentChapters = getParentChapters(chapters, currentChapter || '');

    if (isLoadingContent) {
        return <Loader2 />;
    }

    if (error) {
        return <div>Error loading book: {error?.message}</div>;
    }

    return (
        <div className="book-reader" style={{ position: 'relative' }}>
            {/* Внедрение CSS-стилей */}
            {cssContent && <style>{cssContent} </style>}

            {/* Всплывающее окно с оглавлением */}
            <ChaptersPopup
                mockChapters={chapters}
                currentChapter={currentChapter}
                setCurrentChapter={setCurrentChapter}
                setIsScrollingInPopup={setIsScrollingInPopup} // Передаем управление скроллом
            />

            <div className="page-navigation flex justify-center mb-2 relative">
                <button onClick={handlePrev} disabled={!currentChapter} className="nav-button absolute top-7 right-[50%]">
                    <ArrowLeft />
                </button>
                {/* Отображение текущей главы */}
                <div className="current-chapter-title text-[12px] font-bold" style={{ margin: '0 20px', textAlign: 'center' }}>
                    {parentChapters.map((chapter, index) => (
                        <span key={index}>
                            {chapter.label} {index < parentChapters.length - 1 ? ' » ' : ''} {chapter.href}
                        </span>
                    ))}
                </div>
                <button onClick={handleNext} disabled={!currentChapter} className="nav-button absolute top-7 left-[50%]">
                    <ArrowRight />
                </button>
            </div>

            {/* Основное содержимое книги */}
            <PagedText text={content} onNextChapter={handleNext} onPrevChapter={handlePrev} />
        </div>
    );
};

export default BookReader;

================
File: ui/ChaptersPopup.tsx
================
import { useState } from 'react';
import { ChevronRight, ChevronDown, AlignLeft } from 'lucide-react';
import { Popover, PopoverContent, PopoverTrigger } from '@/shared/ui/components/ui/popover';

interface Chapter {
    label: string;
    href: string;
    cfi: string;
    level: number;
    children?: Chapter[];
}

interface ChaptersPopupProps {
    mockChapters: Chapter[];
    currentChapter: string;
    setCurrentChapter: (href: string) => void;
    setIsScrollingInPopup: (isScrolling: boolean) => void; // Новый пропс для передачи состояния скролла
}

export const ChaptersPopup = ({ mockChapters, currentChapter, setCurrentChapter, setIsScrollingInPopup }: ChaptersPopupProps) => {
    const [expandedChapters, setExpandedChapters] = useState<Set<string>>(new Set());

    const toggleChapter = (href: string) => {
        setExpandedChapters((prev) => {
            const newSet = new Set(prev);
            if (newSet.has(href)) {
                newSet.delete(href);
            } else {
                newSet.add(href);
            }
            return newSet;
        });
    };

    const handleScroll = () => {
        setIsScrollingInPopup(true);
    };

    const handleMouseLeave = () => {
        setIsScrollingInPopup(false);
    };

    const renderChapter = (chapter: Chapter, parentExpanded: boolean = true) => {
        const isExpanded = expandedChapters.has(chapter.href);
        const hasChildren = chapter.children && chapter.children.length > 0;

        if (!parentExpanded && chapter.level !== 1) return null;

        return (
            <div key={chapter.href} className="w-full">
                <div
                    onClick={() => setCurrentChapter(chapter.href)}
                    className={`flex items-center p-2 cursor-pointer hover:bg-slate-100 ${currentChapter === chapter.href ? 'bg-slate-200' : ''}`}
                    style={{
                        paddingLeft: `${chapter.level * 12}px`,
                    }}
                >
                    {hasChildren ? (
                        <button
                            onClick={(e) => {
                                e.stopPropagation();
                                toggleChapter(chapter.href);
                            }}
                            className="mr-2 flex items-center justify-center w-4 h-4 focus:outline-none"
                            aria-expanded={isExpanded}
                            aria-label={isExpanded ? 'Свернуть раздел' : 'Развернуть раздел'}
                        >
                            {isExpanded ? <ChevronDown className="w-4 h-4 flex-shrink-0" /> : <ChevronRight className="w-4 h-4 flex-shrink-0" />}
                        </button>
                    ) : (
                        // Заполнитель для выравнивания
                        <span className="mr-2 w-4 h-4 inline-block"></span>
                    )}
                    <span className="truncate">{chapter.label}</span>
                </div>
                {isExpanded && hasChildren && <div>{chapter.children!.map((subChapter) => renderChapter(subChapter, isExpanded))}</div>}
            </div>
        );
    };

    return (
        <Popover>
            <PopoverTrigger>
                <AlignLeft className="ml-4" />
            </PopoverTrigger>
            <PopoverContent className="w-[400px] p-0">
                <div
                    className="h-[400px] overflow-y-auto overflow-x-hidden hide-scrollbar"
                    onScroll={handleScroll} // Отслеживаем скролл
                    onMouseLeave={handleMouseLeave} // Сброс состояния скролла при выходе мыши
                >
                    {mockChapters.map((chapter) => renderChapter(chapter))}
                </div>
            </PopoverContent>
        </Popover>
    );
};

================
File: ui/PagedText.tsx
================
import React, { useState, useEffect, useRef } from 'react';
import parse from 'html-react-parser';

interface PagedTextProps {
    text?: string;
    onNextChapter: () => void;
    onPrevChapter: () => void;
}

export default function PagedText({ text = '', onNextChapter, onPrevChapter }: PagedTextProps) {
    const [pages, setPages] = useState<string[][]>([]);
    const [currentPage, setCurrentPage] = useState(0);
    const containerRef = useRef<HTMLDivElement>(null);

    useEffect(() => {
        if (!text) {
            setPages([]);
            return;
        }

        const paginateContent = async () => {
            const availableHeight = window.innerHeight - 150; // Высота доступного пространства
            const availableWidth = containerRef.current?.offsetWidth || window.innerWidth;

            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(text, 'text/html');
            const allNodes = Array.from(htmlDoc.body.childNodes);

            const pagesArray: string[][] = [];
            let currentNodes: Node[] = [];

            // Создаём временный контейнер для измерения высоты
            const tempDiv = document.createElement('div');
            tempDiv.style.position = 'absolute';
            tempDiv.style.visibility = 'hidden';
            tempDiv.style.width = `${availableWidth}px`;
            tempDiv.style.height = `${availableHeight}px`;
            tempDiv.style.columnCount = '2';
            tempDiv.style.columnGap = '40px';
            tempDiv.style.padding = '10px';
            tempDiv.style.boxSizing = 'border-box';
            tempDiv.style.fontSize = '20px';
            tempDiv.style.lineHeight = '1.5';
            tempDiv.style.fontFamily = 'Segoe UI';
            tempDiv.style.overflow = 'hidden';

            document.body.appendChild(tempDiv);

            let index = 0;

            while (index < allNodes.length) {
                const node = allNodes[index];
                currentNodes.push(node);

                tempDiv.innerHTML = '';
                currentNodes.forEach((n) => tempDiv.appendChild(n.cloneNode(true)));

                // Ждём загрузки изображений
                const images = tempDiv.getElementsByTagName('img');
                const imagePromises = Array.from(images).map((img) => {
                    return new Promise<void>((resolve) => {
                        if (img.complete) {
                            resolve();
                        } else {
                            img.onload = () => resolve();
                            img.onerror = () => resolve();
                        }
                    });
                });
                await Promise.all(imagePromises);

                const height = tempDiv.scrollHeight;

                if (height > availableHeight && currentNodes.length > 1) {
                    // Удаляем последний узел, который не поместился
                    currentNodes.pop();

                    // Генерируем HTML текущей страницы
                    const pageContent = currentNodes.map((n) => n.outerHTML || n.textContent).join('');

                    // Добавляем страницу в массив страниц
                    pagesArray.push([pageContent]);

                    // Начинаем новую страницу с узла, который не поместился
                    currentNodes = [];
                    continue;
                } else if (height > availableHeight) {
                    // Узел не помещается на страницу даже в одиночку
                    // Нужно обработать это отдельно (например, уменьшить размер изображения или обрезать контент)
                    // Для простоты добавим как есть
                    const pageContent = currentNodes.map((n) => n.outerHTML || n.textContent).join('');
                    pagesArray.push([pageContent]);
                    currentNodes = [];
                }

                index++;
            }

            // Добавляем последнюю страницу
            if (currentNodes.length > 0) {
                const pageContent = currentNodes.map((n) => n.outerHTML || n.textContent).join('');
                pagesArray.push([pageContent]);
            }

            document.body.removeChild(tempDiv);
            setPages(pagesArray);
            setCurrentPage(0);
        };

        paginateContent();

        window.addEventListener('resize', paginateContent);
        return () => {
            window.removeEventListener('resize', paginateContent);
        };
    }, [text]);

    const goToPreviousPage = () => {
        if (currentPage === 0) {
            onPrevChapter();
        } else {
            setCurrentPage((prev) => Math.max(0, prev - 1));
        }
    };

    const goToNextPage = () => {
        if (currentPage === pages.length - 1) {
            onNextChapter();
        } else {
            setCurrentPage((prev) => Math.min(pages.length - 1, prev + 1));
        }
    };

    if (pages.length === 0) {
        return <div className="text-center p-4">Нет текста для отображения.</div>;
    }

    return (
        <div className="mx-auto p-10" ref={containerRef} style={{ height: '100vh', }}>
            {/* Навигация по страницам */}
            <div className="flex justify-center items-center text-[12px]">
                <div className="flex justify-between items-center mb-4">
                    <button onClick={goToPreviousPage} className="bg-gray-300 p-2 rounded">
                        « Назад
                    </button>

                    <span className="text-[12px]">
                        Страница {currentPage + 1}/{pages.length}
                    </span>

                    <button onClick={goToNextPage} className="bg-gray-300 p-2 rounded">
                        Вперед »
                    </button>
                </div>
            </div>

            {/* Отображение текущей страницы */}
            <div
                className="content"
                style={{
                    height: 'calc(100vh - 150px)', // Высота контента с учётом навигации и отступов

                    columnCount: 2,
                    columnGap: '40px',
                    padding: '10px',
                    boxSizing: 'border-box',
                    fontSize: '20px',
                    lineHeight: '1.5',
                    fontFamily: 'Segoe UI',
                    position: 'relative',
                }}
            >
                {parse(pages[currentPage][0] || '')}
            </div>
        </div>
    );
}
