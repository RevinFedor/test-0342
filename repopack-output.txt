================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-10-23T08:06:57.425Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
hooks/useChapter.ts
hooks/useChapterDuplicate.ts
hooks/useEPUB.ts
model/booksApiSlice.ts
model/types.ts
model/utils.ts
ui/BookReader.tsx
ui/ChaptersPopup.tsx
ui/PagedText.tsx

================================================================
Repository Files
================================================================

================
File: hooks/useChapter.ts
================
// hooks/useChapter.ts
import { useState, useEffect } from 'react';
import JSZip from 'jszip';
import DOMPurify from 'dompurify';
import { getFullImagePath } from '../model/utils';

interface UseChapterProps {
    bookFile: ArrayBuffer | null;
    href: string;
    images: Record<string, string>;
}

interface HeadingInfo {
    tag: string;
    text: string;
    index: number;
}

const useChapter = ({ bookFile, href, images }: UseChapterProps) => {
    const [content, setContent] = useState<string | null>(null);
    const [error, setError] = useState<string | null>(null);
    const [headings, setHeadings] = useState<HeadingInfo[]>([]); // Новое состояние для заголовков

    useEffect(() => {
        if (!bookFile) {
            return;
        }
        const loadChapter = async () => {
            try {
                console.log('Loading chapter with href:', href);
                const zip = await JSZip.loadAsync(bookFile);
                const baseHref = href.split('#')[0];
                let chapterFile = zip.file(`OPS/${baseHref}`);
                if (!chapterFile) {
                    const availableFiles = Object.keys(zip.files);
                    const similarFile = availableFiles.find((file) => file.toLowerCase() === baseHref.toLowerCase());
                    if (similarFile) {
                        chapterFile = zip.file(similarFile);
                        console.warn(`Found a similar file name: ${similarFile}`);
                    } else {
                        throw new Error(`Chapter file not found: ${baseHref}`);
                    }
                }

                let contentFile = await chapterFile.async('string');
                contentFile = contentFile.replace(/<\?xml.*?\?>\s*/g, '');

                const parser = new DOMParser();
                const doc = parser.parseFromString(contentFile, 'application/xhtml+xml');
                const body = doc.body;

                if (body) {
                    const imagesInContent = body.querySelectorAll('img, image');
                    imagesInContent.forEach((imgElement) => {
                        const src = imgElement.getAttribute('src') || imgElement.getAttributeNS('http://www.w3.org/1999/xlink', 'href');
                        if (src) {
                            const imagePath = getFullImagePath(baseHref, src);
                            const imageUri = images[imagePath] || images[src];

                            if (imageUri) {
                                if (imgElement instanceof HTMLImageElement || imgElement instanceof SVGImageElement) {
                                    if (imgElement instanceof HTMLImageElement) {
                                        imgElement.setAttribute('src', imageUri);
                                    } else {
                                        imgElement.setAttributeNS('http://www.w3.org/1999/xlink', 'href', imageUri);
                                    }

                                    imgElement.style.display = 'block';
                                    imgElement.style.marginLeft = 'auto';
                                    imgElement.style.marginRight = 'auto';
                                    imgElement.style.maxWidth = '100%';
                                    imgElement.style.height = 'auto';
                                }
                            } else {
                                console.warn(`Image not found: ${src}`);
                            }
                        }
                    });

                    const serializer = new XMLSerializer();
                    let bodyContent = serializer.serializeToString(body);
                    bodyContent = DOMPurify.sanitize(bodyContent);
                    setContent(bodyContent);

                    // Извлечение заголовков и логирование
                    extractAndLogHeadings(body);
                } else {
                    throw new Error('The <body> tag was not found in the chapter content.');
                }
            } catch (err: any) {
                console.error('Error loading chapter content:', err);
                setError(err.message);
            }
        };

        if (bookFile && href) {
            loadChapter();
        }
    }, [href, bookFile, images]);

    /**
     * Функция для извлечения заголовков из DOM и логирования их.
     * @param body DOM элемент <body>
     */
    const extractAndLogHeadings = (body: HTMLElement) => {
        const headingTags = ['H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'P'];
        const headingsList: HeadingInfo[] = [];
        let index = 0;

        body.querySelectorAll('*').forEach((element) => {
            if (headingTags.includes(element.tagName)) {
                const text = element.textContent?.trim() || '';
                // Учитываем только заголовки с текстом
                if (text.length > 0) {
                    headingsList.push({
                        tag: element.tagName,
                        text,
                        index: index++,
                    });
                }
            }
        });

        setHeadings(headingsList);
        console.log('Extracted Headings:', headingsList);
    };

    return { content, error, headings };
};

export default useChapter;

================
File: hooks/useChapterDuplicate.ts
================
// src/features/bookReader/hooks/useChapterDuplicate.ts

import { useState, useEffect } from 'react';
import { loadChapterContent, computeHash, flattenChapters } from '../model/utils';
import { Chapter } from '../model/types';


/**
 * Интерфейс для входных параметров хука useChapterDuplicate.
 */
interface useChapterDuplicateProps {
    bookFile: ArrayBuffer | null;
    chapters: Chapter[];
}

/**
 * Интерфейс для выходных данных хука useChapterDuplicate.
 */
interface useChapterDuplicateReturn {
    duplicates: Record<string, string[]>; // хеш и список href
    loading: boolean;
    error: string | null;
}

/**
 * Хук useChapterDuplicate находит дублирующиеся главы на основе содержимого.
 * @param bookFile - EPUB файл как ArrayBuffer
 * @param chapters - список глав
 * @returns { duplicates, loading, error }
 */
const useChapterDuplicate = ({ bookFile, chapters }: useChapterDuplicateProps): useChapterDuplicateReturn => {
    const [duplicates, setDuplicates] = useState<Record<string, string[]>>({});
    const [loading, setLoading] = useState<boolean>(false);
    const [error, setError] = useState<string | null>(null);

    useEffect(() => {
        const findDuplicates = async () => {
            if (!bookFile || chapters.length === 0) {
                setError('EPUB файл или список глав не предоставлены.');
                return;
            }

            setLoading(true);
            setError(null);

            try {
                const flatChapters = flattenChapters(chapters);
                const hashMap: Record<string, string[]> = {};

                for (const chapter of flatChapters) {
                    const href = chapter.href;
                    const content = await loadChapterContent(bookFile, href);
                    if (content) {
                        const hash = await computeHash(content);
                        if (hashMap[hash]) {
                            hashMap[hash].push(href);
                        } else {
                            hashMap[hash] = [href];
                        }
                    } else {
                        console.warn(`Содержимое главы не загружено: ${href}`);
                    }
                }

                // Фильтруем только те хеши, у которых более одной главы
                const duplicatesFound: Record<string, string[]> = {};
                Object.entries(hashMap).forEach(([hash, hrefs]) => {
                    if (hrefs.length > 1) {
                        duplicatesFound[hash] = hrefs;
                    }
                });

                setDuplicates(duplicatesFound);

                // if (Object.keys(duplicatesFound).length === 0) {
                //     console.log('Дублирующиеся главы не найдены.');
                // } else {
                //     console.log('Найдены дублирующиеся главы:', duplicatesFound);
                // }
            } catch (err: any) {
                console.error('Ошибка при поиске дублирующихся глав:', err);
                setError(err.message || 'Неизвестная ошибка');
            } finally {
                setLoading(false);
            }
        };

        findDuplicates();
    }, [bookFile, chapters]);

    return { duplicates, loading, error };
};

export default useChapterDuplicate;

================
File: hooks/useEPUB.ts
================
// src/features/bookReader/hooks/useEPUB.ts
import { useState, useEffect } from 'react';
import JSZip from 'jszip';
import DOMPurify from 'dompurify';
import { parseNavPoints, getFullImagePath } from '../model/utils'; // Вынесите функции в shared/utils
import { Chapter } from '../model/types';

const useEPUB = (bookFile: Blob | null) => {
    const [chapters, setChapters] = useState<Chapter[]>([]);
    const [cssContent, setCssContent] = useState<string>('');
    const [images, setImages] = useState<Record<string, string>>({});
    const [error, setError] = useState<string | null>(null);

    useEffect(() => {
        const loadEpub = async () => {
            if (bookFile) {
                try {
                    const zip = await JSZip.loadAsync(bookFile);

                    // Загрузка TOC
                    const tocFile = zip.file(/toc\.ncx$/i)[0];
                    if (!tocFile) throw new Error('toc.ncx не найден');

                    const tocContent = await tocFile.async('string');
                    const parser = new DOMParser();
                    const tocDoc = parser.parseFromString(tocContent, 'application/xml');
                    const rootNavPoints = tocDoc.querySelectorAll('navMap > navPoint');
                    const newChapters = parseNavPoints(rootNavPoints);
                    setChapters(newChapters);

                    // Загрузка CSS
                    const cssFiles = Array.from(zip.file(/.*\.css$/i));
                    const cssContents = await Promise.all(cssFiles.map((file) => file.async('string')));
                    setCssContent(cssContents.join('\n'));

                    // Загрузка изображений
                    const imageFiles = Array.from(zip.file(/\.(png|jpg|jpeg|gif|svg)$/i));
                    const imageMap: Record<string, string> = {};
                    await Promise.all(
                        imageFiles.map(async (file) => {
                            const data = await file.async('base64');
                            const extensionMatch = file.name.match(/\.(png|jpg|jpeg|gif|svg)$/i);
                            const extension = extensionMatch ? extensionMatch[1].toLowerCase() : 'png';
                            const mimeType = extension === 'svg' ? 'image/svg+xml' : `image/${extension === 'jpg' ? 'jpeg' : extension}`;
                            const dataUri = `data:${mimeType};base64,${data}`;
                            imageMap[file.name] = dataUri;
                        })
                    );

                    setImages(imageMap);
                } catch (err) {
                    console.error('Ошибка при загрузке EPUB:', err);
                    setError(err.message);
                }
            }
        };

        loadEpub();
    }, [bookFile]);

    return { chapters, cssContent, images, error };
};

export default useEPUB;

================
File: model/booksApiSlice.ts
================
import { api } from '@/app/api/apiSlice';
import JSZip from 'jszip';

export interface Book {
    _id: string;
    filePath: string;
    title?: string;
    creator?: string;
    description?: string;
}

export interface ParsedBook extends Omit<Book, '_id'> {
    title: string;
    creator: string;
    description: string;
    content: ArrayBuffer;
}

export const booksApi = api.injectEndpoints({
    endpoints: (builder) => ({
        getBooks: builder.query<Book[], void>({
            query: () => 'books',
            providesTags: ['Books'],
        }),
        getBookById: builder.query<ArrayBuffer, string>({
            query: (id) => ({
                url: `http://localhost:3500/api/books/${id}`,
                responseHandler: (response) => response.arrayBuffer(), // Обработка ответа как ArrayBuffer
            }),
        }),

        getBookContent: builder.query<ParsedBook, string>({
            query: (filePath) => ({
                url: 'http://localhost:3500' + filePath,
                responseHandler: (response) => response.arrayBuffer(),
            }),
            transformResponse: async (content: ArrayBuffer, _, filePath) => {
                const zip = await JSZip.loadAsync(content);
                const metadataFile = zip.file('OEBPS/content.opf') || zip.file('content.opf');
                const metadataContent = metadataFile ? await metadataFile.async('text') : '';

                const parser = new DOMParser();
                const metadataDoc = parser.parseFromString(metadataContent, 'application/xml');
                const title = metadataDoc.querySelector('title')?.textContent || 'Unknown Title';
                const creator = metadataDoc.querySelector('creator')?.textContent || 'Unknown Author';
                const description = metadataDoc.querySelector('description')?.textContent || 'No description available';

                return {
                    title,
                    creator,
                    description,
                    content,
                    filePath,
                };
            },
        }),
        uploadBook: builder.mutation<void, FormData>({
            query: (formData) => ({
                url: 'books',
                method: 'POST',
                body: formData,
            }),
            invalidatesTags: ['Books'],
        }),
        deleteBook: builder.mutation<void, string>({
            query: (id) => ({
                url: `books/${id}`,
                method: 'DELETE',
            }),
            invalidatesTags: ['Books'],
        }),
    }),
});

export const { useGetBooksQuery, useUploadBookMutation, useDeleteBookMutation, useGetBookByIdQuery, useGetBookContentQuery } = booksApi;

================
File: model/types.ts
================
export interface Chapter {
    label: string;
    href: string;
    cfi: string; // CFI можно вычислить позже, если потребуется
    level: number; // Представляет уровень вложенности
    children?: Chapter[];
    
}

================
File: model/utils.ts
================
// src/shared/utils/epubUtils.ts
import JSZip from 'jszip';
import { Chapter } from './types';
import DOMPurify from 'dompurify';

export const parseNavPoints = (navPoints: NodeListOf<Element>, currentLevel: number = 1): Chapter[] => {
    const chapters: Chapter[] = [];

    navPoints.forEach((navPoint) => {
        const label = navPoint.querySelector('navLabel > text')?.textContent || 'Глава';
        const href = navPoint.querySelector('content')?.getAttribute('src') || '';

        const chapter: Chapter = {
            label,
            href,
            cfi: '',
            level: currentLevel,
            children: [],
        };

        const childNavPoints = navPoint.querySelectorAll(':scope > navPoint');
        if (childNavPoints.length > 0) {
            chapter.children = parseNavPoints(childNavPoints, currentLevel + 1);
        }

        chapters.push(chapter);
    });

    return chapters;
};

export const getFullImagePath = (baseHref: string, src: string): string => {
    // If the src is already an absolute path like 'OPS/images/...'
    if (src.startsWith('OPS/')) {
        return src;
    }

    // If the src is relative, ensure that 'OPS/' is prepended if it's missing
    const chapterPath = baseHref.substring(0, baseHref.lastIndexOf('/') + 1);
    const fullPath = chapterPath + src;

    if (!fullPath.startsWith('OPS/')) {
        return 'OPS/' + fullPath;
    }

    return fullPath;
};

/**
 * Хелпер-функция для разворачивания иерархии глав.
 * @param chapters - список глав
 * @returns плоский список глав
 */
export const flattenChapters = (chapters: Chapter[]): Chapter[] => {
    const flat: Chapter[] = [];
    const traverse = (chapterList: Chapter[]) => {
        chapterList.forEach((chapter) => {
            flat.push(chapter);
            if (chapter.children && chapter.children.length > 0) {
                traverse(chapter.children);
            }
        });
    };
    traverse(chapters);
    return flat;
};

//! Функция для получения всех родительских глав до третьего или четвертого уровня
export const getParentChapters = (chapters: Chapter[], href: string): Chapter[] => {
    const parents: Chapter[] = [];

    const findChapter = (chapterList: Chapter[], currentHref: string, ancestors: Chapter[] = []): boolean => {
        for (const chapter of chapterList) {
            const newAncestors = [...ancestors, chapter];
            if (chapter.href === currentHref) {
                // Добавляем найденных родителей
                parents.push(...newAncestors);
                return true;
            }

            // Если у главы есть вложенные, ищем в них
            if (chapter.children && chapter.children.length > 0) {
                const found = findChapter(chapter.children, currentHref, newAncestors);
                if (found) {
                    return true;
                }
            }
        }
        return false;
    };

    findChapter(chapters, href);
    return parents;
};

//! ++++++++++++++++++++++
/**
 * Получает базовый href, удаляя фрагмент.
 * @param href - полный href с фрагментом
 * @returns базовый href без фрагмента
 */
export const getBaseHref = (href: string): string => {
    const [baseHref] = href.split('#');
    return baseHref;
};

/**
 * Загружает содержимое главы по href.
 * @param bookFile - EPUB файл как ArrayBuffer
 * @param href - href главы
 * @returns содержимое главы как строка или null в случае ошибки
 */
export const loadChapterContent = async (bookFile: ArrayBuffer, href: string): Promise<string | null> => {
    try {
        const zip = await JSZip.loadAsync(bookFile);
        const baseHref = getBaseHref(href);
        let chapterFile = zip.file(`OPS/${baseHref}`);

        if (!chapterFile) {
            const availableFiles = Object.keys(zip.files);
            const similarFile = availableFiles.find((file) => file.toLowerCase() === baseHref.toLowerCase());
            if (similarFile) {
                chapterFile = zip.file(similarFile);
            } else {
                return null;
            }
        }

        let chapterContent = await chapterFile.async('string');
        // Удаляем XML декларацию, если она есть
        chapterContent = chapterContent.replace(/<\?xml.*?\?>\s*/g, '');

        // Очищаем содержимое с помощью DOMPurify
        const parser = new DOMParser();
        const doc = parser.parseFromString(chapterContent, 'application/xhtml+xml');
        const body = doc.body;

        if (!body) {
            console.warn('Тег <body> не найден в содержимом главы.');
            return null;
        }

        // Сериализуем содержимое <body>
        const serializer = new XMLSerializer();
        let sanitizedContent = serializer.serializeToString(body);
        sanitizedContent = DOMPurify.sanitize(sanitizedContent);
        return sanitizedContent;
    } catch (err) {
        console.error('Ошибка при загрузке содержимого главы:', err);
        return null;
    }
};

/**
 * Вычисляет SHA-256 хеш для заданной строки.
 * @param content - содержимое главы
 * @returns хеш в формате hex
 */
export const computeHash = async (content: string): Promise<string> => {
    const encoder = new TextEncoder();
    const data = encoder.encode(content);
    const hashBuffer = await crypto.subtle.digest('SHA-256', data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map((b) => b.toString(16).padStart(2, '0')).join('');
    return hashHex;
};

================
File: ui/BookReader.tsx
================
import React, { useEffect, useState,useRef } from 'react';
import { useParams } from 'react-router-dom';
import { useGetBookByIdQuery } from '../model/booksApiSlice';
import { ArrowLeft, ArrowRight, Loader2 } from 'lucide-react';

import { ChaptersPopup } from './ChaptersPopup';
import useChapter from '../hooks/useChapter';
import useEPUB from '../hooks/useEPUB';
import PagedText from './PagedText';
import { flattenChapters, getParentChapters } from '../model/utils';
import useChapterDuplicate from '../hooks/useChapterDuplicate';

const extractChapterTitles = (chapters) => {
    const titles = [];

    const extractTitlesRecursively = (chapterList) => {
        chapterList.forEach((chapter) => {
            titles.push(chapter.label); // Добавляем заголовок текущего уровня
            if (chapter.children && chapter.children.length > 0) {
                extractTitlesRecursively(chapter.children); // Рекурсивно обрабатываем дочерние элементы
            }
        });
    };

    extractTitlesRecursively(chapters);

    return titles;
};

const BookReader: React.FC = () => {
    const { id } = useParams<{ id: string }>();
    const [currentChapter, setCurrentChapter] = useState<string>(null);
    const [isScrollingInPopup, setIsScrollingInPopup] = useState(false); // Новый state для отслеживания скролла внутри оглавления
    

    const { data: bookFile, isLoading: isLoadingContent, error } = useGetBookByIdQuery(id);
    const { chapters, cssContent, images } = useEPUB(bookFile);

    useEffect(() => {
        if (chapters.length > 0 && !currentChapter) {
            setCurrentChapter(chapters[0].href);
        }
    }, [chapters, currentChapter]);
    const knownChapterTitles = extractChapterTitles(chapters);
    const { content, headings } = useChapter({
        bookFile,
        href: currentChapter,
        images,
        knownChapterTitles,
    });

    //! Используем хук для поиска дублирующихся глав
    const {
        duplicates,
        loading: isLoadingDuplicates,
        error: duplicatesError,
    } = useChapterDuplicate({
        bookFile,
        chapters,
    });

    //! настройка скролла для popup оглавления
    const handleWheel = (event: WheelEvent) => {
        if (!isScrollingInPopup) {
            if (event.deltaY < 0) {
            } else if (event.deltaY > 0) {
            }
        }
    };

    useEffect(() => {
        window.addEventListener('wheel', handleWheel);

        return () => {
            window.removeEventListener('wheel', handleWheel);
        };
    }, [isScrollingInPopup]);

    //!логика переключения глав

    // Логика переключения глав с учётом вложенности
    const handleNext = () => {
        const flatChapters = flattenChapters(chapters); // Все главы в одном массиве
        const currentChapterIndex = flatChapters.findIndex((ch) => ch.href === currentChapter);

        if (currentChapterIndex !== -1 && currentChapterIndex < flatChapters.length - 1) {
            setCurrentChapter(flatChapters[currentChapterIndex + 1].href);
        }
    };

    const handlePrev = () => {
        const flatChapters = flattenChapters(chapters); // Все главы в одном массиве
        const currentChapterIndex = flatChapters.findIndex((ch) => ch.href === currentChapter);

        if (currentChapterIndex > 0) {
            setCurrentChapter(flatChapters[currentChapterIndex - 1].href);
        }
    };

    const parentChapters = getParentChapters(chapters, currentChapter || '');

    if (isLoadingContent) {
        return <Loader2 />;
    }

    if (error) {
        return <div>Error loading book: {error?.message}</div>;
    }

    return (
        <div className="book-reader" style={{ position: 'relative' }}>
            {/* Внедрение CSS-стилей */}
            {cssContent && <style>{cssContent} </style>}

            {/* Всплывающее окно с оглавлением */}
            <ChaptersPopup
                mockChapters={chapters}
                currentChapter={currentChapter}
                setCurrentChapter={setCurrentChapter}
                setIsScrollingInPopup={setIsScrollingInPopup} // Передаем управление скроллом
            />

            <div className="page-navigation flex justify-center mb-2 relative">
                <button onClick={handlePrev} disabled={!currentChapter} className="nav-button absolute top-7 right-[50%]">
                    <ArrowLeft />
                </button>
                {/* Отображение текущей главы */}
                <div className="current-chapter-title text-[12px] font-bold" style={{ margin: '0 20px', textAlign: 'center' }}>
                    {parentChapters.map((chapter, index) => (
                        <span key={index}>
                            {chapter.label} {index < parentChapters.length - 1 ? ' » ' : ''} {chapter.href}
                        </span>
                    ))}
                </div>
                <button onClick={handleNext} disabled={!currentChapter} className="nav-button absolute top-7 left-[50%]">
                    <ArrowRight />
                </button>
            </div>

            {/* Основное содержимое книги */}
            <PagedText text={content} onNextChapter={handleNext} onPrevChapter={handlePrev} />
        </div>
    );
};

export default BookReader;

================
File: ui/ChaptersPopup.tsx
================
import { useState } from 'react';
import { ChevronRight, ChevronDown, AlignLeft } from 'lucide-react';
import { Popover, PopoverContent, PopoverTrigger } from '@/shared/ui/components/ui/popover';

interface Chapter {
    label: string;
    href: string;
    cfi: string;
    level: number;
    children?: Chapter[];
}

interface ChaptersPopupProps {
    mockChapters: Chapter[];
    currentChapter: string;
    setCurrentChapter: (href: string) => void;
    setIsScrollingInPopup: (isScrolling: boolean) => void; // Новый пропс для передачи состояния скролла
}

export const ChaptersPopup = ({ mockChapters, currentChapter, setCurrentChapter, setIsScrollingInPopup }: ChaptersPopupProps) => {
    const [expandedChapters, setExpandedChapters] = useState<Set<string>>(new Set());


    const toggleChapter = (href: string) => {
        setExpandedChapters((prev) => {
            const newSet = new Set(prev);
            if (newSet.has(href)) {
                newSet.delete(href);
            } else {
                newSet.add(href);
            }
            return newSet;
        });
    };

    const handleScroll = () => {
        setIsScrollingInPopup(true);
    };

    const handleMouseLeave = () => {
        setIsScrollingInPopup(false);
    };

    const renderChapter = (chapter: Chapter, parentExpanded: boolean = true) => {
        const isExpanded = expandedChapters.has(chapter.href);
        const hasChildren = chapter.children && chapter.children.length > 0;

        if (!parentExpanded && chapter.level !== 1) return null;

        return (
            <div key={chapter.href} className="w-full">
                <div
                    onClick={() => setCurrentChapter(chapter.href)}
                    className={`flex items-center p-2 cursor-pointer hover:bg-slate-100 ${currentChapter === chapter.href ? 'bg-slate-200' : ''}`}
                    style={{
                        paddingLeft: `${chapter.level * 12}px`,
                    }}
                >
                    {hasChildren ? (
                        <button
                            onClick={(e) => {
                                e.stopPropagation();
                                toggleChapter(chapter.href);
                            }}
                            className="mr-2 flex items-center justify-center w-4 h-4 focus:outline-none"
                            aria-expanded={isExpanded}
                            aria-label={isExpanded ? 'Свернуть раздел' : 'Развернуть раздел'}
                        >
                            {isExpanded ? <ChevronDown className="w-4 h-4 flex-shrink-0" /> : <ChevronRight className="w-4 h-4 flex-shrink-0" />}
                        </button>
                    ) : (
                        // Заполнитель для выравнивания
                        <span className="mr-2 w-4 h-4 inline-block"></span>
                    )}
                    <span className="truncate">{chapter.label}</span>
                </div>
                {isExpanded && hasChildren && <div>{chapter.children!.map((subChapter) => renderChapter(subChapter, isExpanded))}</div>}
            </div>
        );
    };

    return (
        <Popover>
            <PopoverTrigger>
                <AlignLeft className="ml-4" />
            </PopoverTrigger>
            <PopoverContent className="w-[400px] p-0">
                <div
                    className="h-[400px] overflow-y-auto overflow-x-hidden hide-scrollbar"
                    onScroll={handleScroll} // Отслеживаем скролл
                    onMouseLeave={handleMouseLeave} // Сброс состояния скролла при выходе мыши
                >
                    {mockChapters.map((chapter) => renderChapter(chapter))}
                </div>
            </PopoverContent>
        </Popover>
    );
};

================
File: ui/PagedText.tsx
================
import React, { useState, useEffect, useRef } from 'react';
import { ChevronLeft, ChevronRight } from 'lucide-react';
import { Button } from '@/shared/ui/components/ui/button';
import parse, { domToReact, HTMLReactParserOptions, Element as DomElement } from 'html-react-parser';

// Функция для преобразования строки стилей в объект
const parseStyle = (styleString: string): React.CSSProperties => {
    return styleString.split(';').reduce((style: React.CSSProperties, rule) => {
        const [key, value] = rule.split(':').map((item) => item.trim());
        if (key && value) {
            // Преобразование kebab-case в camelCase
            const camelCaseKey = key.replace(/-([a-z])/g, (g) => g[1].toUpperCase()) as keyof React.CSSProperties;
            style[camelCaseKey] = value;
        }
        return style;
    }, {});
};

interface PagedTextProps {
    text?: string;
    maxColumnHeight?: number; // Максимальная высота столбца в пикселях
}

interface Page {
    left: string;
    right: string;
}

export default function PagedText({ text = '', maxColumnHeight = 700 }: PagedTextProps) {
    const [pages, setPages] = useState<Page[]>([]);
    const [currentPage, setCurrentPage] = useState(0);
    const isSplittingRef = useRef(false); // Флаг для предотвращения повторного вызова

    useEffect(() => {
        if (!text) {
            setPages([]);
            return;
        }

        // Предотвращение повторного вызова функции разбиения
        if (isSplittingRef.current) return;
        isSplittingRef.current = true;

        //! функция для обработки изображений заранее 
        const waitForImages = (container: HTMLElement): Promise<void> => {
            const images = container.querySelectorAll('img');
            const promises = Array.from(images).map((img) => {
                if (img.complete) return Promise.resolve();
                return new Promise<void>((resolve) => {
                    img.onload = resolve;
                    img.onerror = resolve;
                });
            });
            return Promise.all(promises).then(() => {});
        };

        const splitHtmlIntoPages = async (html: string, maxHeight: number): Promise<Page[]> => {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = html;

            await waitForImages(tempDiv);
            // Рекурсивная функция для сбора всех элементов
            const collectElements = (node: Node, elements: HTMLElement[]) => {
                if (node.nodeType === Node.ELEMENT_NODE) {
                    const el = node as HTMLElement;
                    // Собираем все блочные элементы
                    if (['P', 'H1', 'H2', 'H3', 'IMG', 'DIV', 'FIGURE', 'SECTION', 'ARTICLE'].includes(el.tagName)) {
                        elements.push(el);
                        // Не рекурсивно обходим детей, если это блочный элемент
                        return;
                    }
                    // Рекурсивно обходим детей для других типов элементов
                    el.childNodes.forEach((child) => collectElements(child, elements));
                }
                // Игнорируем текстовые узлы и другие типы узлов
            };

            const allElements: HTMLElement[] = [];
            tempDiv.childNodes.forEach((child) => collectElements(child, allElements));

            //! console.log(`Total elements to process: ${allElements.length}`);

            // Функция для оценки высоты элемента
            const estimateElementHeight = (el: HTMLElement): number => {
                // Создаём временный контейнер для измерения
                const tempContainer = document.createElement('div');
                tempContainer.style.visibility = 'hidden';
                tempContainer.style.position = 'absolute';
                tempContainer.style.top = '0';
                tempContainer.style.left = '0';
                tempContainer.style.width = '800px'; //! Убедитесь, что это соответствует реальной ширине столбца
                tempContainer.style.fontSize = '16px'; // Установите соответствующие стили
                tempContainer.style.lineHeight = '1.5'; // Установите соответствующие стили

                // Клонируем элемент для измерения
                const clone = el.cloneNode(true) as HTMLElement;

                // Для изображений задаём фиксированные размеры или получаем реальные
                if (clone.tagName === 'IMG') {
                    const img = clone as HTMLImageElement;
                    if (!img.height || img.height === 0) {
                        // Задаём стандартную высоту, если не задана
                        img.style.height = '200px';
                    }
                    // Устанавливаем ширину, чтобы соответствовать колонке
                    img.style.width = '100%';
                    img.style.objectFit = 'contain';
                    img.style.display = 'block'; // Чтобы убрать пробелы снизу
                }

                tempContainer.appendChild(clone);
                document.body.appendChild(tempContainer);
                const height = tempContainer.offsetHeight;
                document.body.removeChild(tempContainer);
                return height;
            };

            const pagesArray: Page[] = [];
            let currentPageContent: Page = { left: '', right: '' };
            let currentColumnHeight = [0, 0]; // [leftHeight, rightHeight]
            let currentColumn = 0; // 0 - left, 1 - right

            for (const element of allElements) {
                const elHeight = estimateElementHeight(element);
                //! console.log(`Element: <${element.tagName.toLowerCase()}>, Estimated Height: ${elHeight}px`);

                if (elHeight > maxHeight) {
                    console.warn(`Element <${element.tagName.toLowerCase()}> exceeds max height and will be skipped.`);
                    continue; // Skip or handle oversized elements separately
                }

                if (currentColumnHeight[currentColumn] + elHeight > maxHeight) {
                    if (currentColumn === 0 && currentColumnHeight[1] === 0) {
                        // Switch to right column
                        currentColumn = 1;
                        //! console.log(`Switching to right column`);
                    } else {
                        // Create a new page
                        pagesArray.push(currentPageContent);
                        //! console.log(`Creating new page`);
                        currentPageContent = { left: '', right: '' };
                        currentColumnHeight = [0, 0];
                        currentColumn = 0; // Start with left column again
                    }
                }

                // Add element to the current column
                const htmlString = element.outerHTML || element.innerHTML || '';
                currentPageContent[currentColumn === 0 ? 'left' : 'right'] += htmlString;
                currentColumnHeight[currentColumn] += elHeight;

                //! console.log(`Added to ${currentColumn === 0 ? 'left' : 'right'} column, new height: ${currentColumnHeight[currentColumn]}px`);
            }

            // Add the last page
            if (currentPageContent.left || currentPageContent.right) {
                pagesArray.push(currentPageContent);
            }

            //! console.log(`Total pages created: ${pagesArray.length}`);
            return pagesArray;
        };

        // Выполняем асинхронное разбиение
        splitHtmlIntoPages(text, maxColumnHeight)
            .then((pagesResult) => {
                setPages(pagesResult);
                setCurrentPage(0);
                isSplittingRef.current = false; // Сбрасываем флаг после завершения
            })
            .catch((error) => {
                console.error('Ошибка при разбиении контента:', error);
                isSplittingRef.current = false; // Сбрасываем флаг даже при ошибке
            });
    }, [text, maxColumnHeight]);

    const goToPreviousPage = () => {
        setCurrentPage((prev) => Math.max(0, prev - 1));
    };

    const goToNextPage = () => {
        setCurrentPage((prev) => Math.min(pages.length - 1, prev + 1));
    };

    if (pages.length === 0) {
        return <div className="text-center p-4">Нет текста для отображения.</div>;
    }

    // Опции для html-react-parser
    const parserOptions: HTMLReactParserOptions = {
        replace: (domNode) => {
            if (domNode.type === 'tag' && domNode.name === 'img') {
                const element = domNode as DomElement;
                const attribs = element.attribs;

                // Преобразование атрибутов
                const props: any = {};
                for (const [key, value] of Object.entries(attribs)) {
                    if (key === 'class') {
                        props['className'] = value;
                    } else if (key === 'style') {
                        props['style'] = parseStyle(value);
                    } else {
                        props[key] = value;
                    }
                }

                // Добавление классов Tailwind CSS
                props.className = `${props.className || ''} max-w-full h-auto`.trim();

                // Обеспечение наличия атрибута alt
                if (!props.alt) {
                    props.alt = '';
                }

                return <img {...props} />;
            }
        },
    };

    return (
        <div className="mx-auto p-10">
            {/* Кнопки навигации перенесены выше */}
            <div className="flex justify-between items-center mb-4">
                <Button onClick={goToPreviousPage} disabled={currentPage === 0} variant="outline">
                    <ChevronLeft className="mr-2 h-4 w-4" /> Предыдущая
                </Button>
                <span>
                    Страница {currentPage + 1} из {pages.length}
                </span>
                <Button onClick={goToNextPage} disabled={currentPage === pages.length - 1} variant="outline">
                    Следующая <ChevronRight className="ml-2 h-4 w-4" />
                </Button>
            </div>
            {pages.length > 0 && (
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4  relative">
                    {' '}
                    {/* Добавлен pl-4 для отступа слева */}
                    {/* Абсолютно позиционированная красная линия */}
                    <div
                        className="absolute left-0 top-0"
                        style={{
                            width: '2px',
                            height: `${maxColumnHeight}px`,
                            backgroundColor: 'red',
                        }}
                    ></div>
                    <div className="border px-4 rounded">{parse(pages[currentPage].left || '', parserOptions)}</div>
                    <div className="border px-4 rounded">{parse(pages[currentPage].right || '', parserOptions)}</div>
                </div>
            )}
        </div>
    );
}
