================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-08-18T20:02:43.077Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
controllers/diaryEntriesController.js
controllers/diaryTagController.js
index.js
models/DiaryModel.js
models/sourceTypes.js
models/TagModel.js
package.json
routes/diaryEntries.js
routes/diaryFilters.js
upload.js
uploadHandlers.js

================================================================
Repository Files
================================================================

================
File: controllers/diaryEntriesController.js
================
const DiaryEntry = require('../models/DiaryModel');
const io = require('../index'); // Импортируем `io`
const path = require('path');
const fs = require('fs');
const mongoose = require('mongoose');
const Tag = require('../models/TagModel');
const { SOURCE_TYPES, FLAT_SOURCE_TYPES, SOURCE_SUBTYPES } = require('../models/sourceTypes');
// http://localhost:3500/api/diaryEntries/

// Получить все записи
exports.getAllDiaryEntries = async (req, res) => {
    try {
        let pipeline = [];

        if (req.query.tags || req.query.sources) {
            let matchConditions = [];

            if (req.query.tags) {
                const tags = req.query.tags.split(',').map((tag) => new mongoose.Types.ObjectId(tag.trim()));
                const isStrict = req.query.strict === 'true';

                if (isStrict) {
                    matchConditions.push({ tags: { $all: tags } });
                } else {
                    matchConditions.push({ tags: { $in: tags } });
                }
            }

            if (req.query.sources) {
                const sources = req.query.sources.split(',');
                const expandedSources = sources.reduce((acc, source) => {
                    if (SOURCE_TYPES[source.toUpperCase()]) {
                        // Если это основной тип источника, добавляем его и все его подтипы
                        return [...acc, source, ...SOURCE_SUBTYPES[source]];
                    }
                    if (source === 'all') {
                        // Если выбрано 'all', добавляем все подтипы Telegram
                        return [...acc, ...SOURCE_SUBTYPES[SOURCE_TYPES.TELEGRAM].filter((subtype) => subtype !== 'all')];
                    }
                    // Если это не основной тип, просто добавляем его
                    return [...acc, source];
                }, []);

                matchConditions.push({
                    $or: [{ 'forward_origin.type': { $in: expandedSources } }, { 'forward_origin.subtype': { $in: expandedSources } }],
                });
            }

            pipeline.push({ $match: { $and: matchConditions } });
        }

        pipeline.push({ $lookup: { from: 'tags', localField: 'tags', foreignField: '_id', as: 'tags' } });

        // Add sorting stage
        const sortField = req.query.sortField || 'date';
        const sortOrder = req.query.sortOrder === 'asc' ? 1 : -1;

        let sortStage = {};
        if (sortField === 'date') {
            sortStage = { createdAt: sortOrder };
        } else if (sortField === 'name') {
            sortStage = { title: sortOrder };
        }

        pipeline.push({ $sort: sortStage });

        const entries = await DiaryEntry.aggregate(pipeline);

        res.status(200).json(entries);
    } catch (err) {
        console.error('Error in getAllDiaryEntries:', err);
        res.status(500).json({ message: err.message });
    }
};

exports.getAvailableFilters = async (req, res) => {
    try {
        const { tags, sources } = req.body;

        // Handle the 'all' case for Telegram sources
        const telegramSubtypes = SOURCE_SUBTYPES[SOURCE_TYPES.TELEGRAM].filter((subtype) => subtype !== 'all');
        const expandedSources = sources.flatMap((source) => (source === 'all' ? telegramSubtypes : source));

        let matchCondition = {};
        if (tags.length > 0) {
            matchCondition.tags = { $in: tags.map((tag) => new mongoose.Types.ObjectId(tag)) };
        }
        if (expandedSources.length > 0) {
            matchCondition.$or = [{ 'forward_origin.type': { $in: expandedSources } }, { 'forward_origin.subtype': { $in: expandedSources } }];
        }

        // Fetch available tags
        const availableTags = await DiaryEntry.distinct('tags', matchCondition);

        // Fetch available sources
        const sourceAggregation = await DiaryEntry.aggregate([
            { $match: matchCondition },
            {
                $group: {
                    _id: null,
                    types: { $addToSet: '$forward_origin.type' },
                    subtypes: { $addToSet: '$forward_origin.subtype' },
                },
            },
            {
                $project: {
                    sources: { $setUnion: ['$types', '$subtypes'] },
                },
            },
        ]);

        let availableSources = sourceAggregation[0]?.sources || [];

        // Add 'all' option if any Telegram subtype is present
        if (availableSources.some((source) => telegramSubtypes.includes(source))) {
            availableSources.push('all');
        }

        // If 'all' was in the original sources, ensure all Telegram subtypes are available
        if (sources.includes('all')) {
            availableSources = [...new Set([...availableSources, ...telegramSubtypes])];
        }

        res.status(200).json({
            availableTags,
            availableSources,
        });
    } catch (err) {
        console.error('Error in getAvailableFilters:', err);
        res.status(500).json({ message: err.message });
    }
};

// Получить одну запись
exports.getDiaryEntryById = async (req, res) => {
    try {
        const entry = await DiaryEntry.findById(req.params.id).populate('tags');
        if (!entry) return res.status(404).json({ message: 'Entry not found' });
        res.status(200).json(entry);
    } catch (err) {
        res.status(500).json({ message: err.message });
    }
};

exports.createDiaryEntry = async (req, res) => {
    const entry = new DiaryEntry(req.body);
    try {
        const newEntry = await entry.save();
        res.status(201).json(newEntry);

        // Notify clients about the new entry
        io.emit('updateEntries', newEntry);
    } catch (err) {
        // console.log(err);
        if (!res.headersSent) {
            res.status(400).json({ message: err.message });
        }
    }
};

// Обновить запись
exports.updateDiaryEntry = async (req, res) => {
    try {
        const updatedEntry = await DiaryEntry.findByIdAndUpdate(req.params.id, req.body, { new: true });
        if (!updatedEntry) return res.status(404).json({ message: 'Entry not found' });
        res.status(200).json(updatedEntry);
    } catch (err) {
        res.status(400).json({ message: err.message });
    }
};

// Удалить запись
exports.deleteDiaryEntry = async (req, res) => {
    try {
        const entry = await DiaryEntry.findById(req.params.id);
        if (!entry) return res.status(404).json({ message: 'Entry not found' });

        // Получаем список тегов заметки
        const entryTags = entry.tags;

        // Удаляем заметку
        await DiaryEntry.findByIdAndDelete(req.params.id);

        // Проверяем каждый тег
        for (let tagId of entryTags) {
            // Проверяем, используется ли тег в других заметках
            const tagUsageCount = await DiaryEntry.countDocuments({ tags: tagId });
            if (tagUsageCount === 0) {
                // Если тег больше нигде не используется, удаляем его из базы данных
                await Tag.findByIdAndDelete(tagId);

                // Оповещаем клиентов об удалении тега
                // io.emit('deleteTag', tagId);
            }
        }

        // Оповещаем клиентов об удалении записи
        // io.emit('deleteEntry', req.params.id);

        res.status(200).json({ message: 'Entry deleted and unused tags cleaned up' });
    } catch (err) {
        console.error('Error in deleteDiaryEntry:', err);
        res.status(500).json({ message: err.message });
    }
};

exports.uploadImageEntry = async (req, res) => {
    try {
        const file = req.file;

        if (!file) {
            return res.status(400).json({ message: 'No file uploaded' });
        }

        const entry = await DiaryEntry.findById(req.params.id);
        if (!entry) {
            return res.status(404).json({ message: 'Entry not found' });
        }

        const filePath = file.path.replace(/\\/g, '/').replace(/^uploads/, '/uploads');
        const newImage = {
            path: filePath,
            fileName: file.originalname,
            dateAdded: new Date(),
            // diaryEntryId: entry._id,
            isHeaderImage: false,
        };

        entry.images.push(newImage);
        await entry.save();

        res.status(200).json(entry);
    } catch (err) {
        res.status(500).json({ message: err.message });
    }
};

// delete image
exports.deleteImageEntry = async (req, res) => {
    try {
        const entry = await DiaryEntry.findById(req.params.id);
        if (!entry) return res.status(404).json({ message: 'Entry not found' });

        const imageIndex = entry.images.findIndex((image) => image._id.toString() === req.params.imageId);
        if (imageIndex === -1) return res.status(404).json({ message: 'Image not found' });

        // Получаем путь к файлу изображения
        const imagePath = path
            .join(__dirname, entry.images[imageIndex].path)
            .toString()
            .replace(/controllers[\\/]/, '');

        // Проверяем, используется ли этот файл в других записях
        const otherEntries = await DiaryEntry.find({
            _id: { $ne: req.params.id },
            'images.fileName': entry.images[imageIndex].fileName,
        });

        // Удаляем запись изображения из базы данных
        entry.images.splice(imageIndex, 1);
        await entry.save();

        fs.unlink(imagePath, (err) => {
            if (err) {
                console.error('Error deleting file:', err);
            }
        });

        res.status(200).json(entry);
    } catch (err) {
        res.status(500).json({ message: err.message });
    }
};

// http://localhost:3500/api/diaryEntries/getDiaryDates
// [
// 	{
// 		"entries": [
// 			{
// 				"id": "66ac729a5a7d1c67bc7098e7",
// 				"title": "Пишу это ночью"
// 			}
// 		],
// 		"date": "2020-04-18"
// 	},

exports.getDiaryDates = async (req, res) => {
    try {
        const entries = await DiaryEntry.aggregate([
            {
                $addFields: {
                    createdAtDate: {
                        $cond: {
                            if: { $eq: [{ $type: '$createdAt' }, 'date'] },
                            then: '$createdAt',
                            else: { $toDate: '$createdAt' },
                        },
                    },
                },
            },
            {
                $match: {
                    createdAtDate: { $ne: null },
                },
            },
            {
                $group: {
                    _id: {
                        $dateToString: { format: '%Y-%m-%d', date: '$createdAtDate' },
                    },
                    entries: {
                        $push: {
                            id: '$_id',
                            title: '$title',
                        },
                    },
                },
            },
            {
                $project: {
                    _id: 0,
                    date: '$_id',
                    entries: 1,
                },
            },
            {
                $sort: { date: 1 },
            },
        ]);

        res.status(200).json(entries);
    } catch (err) {
        console.error('Error in getDiaryDates:', err);
        res.status(500).json({ message: err.message });
    }
};

================
File: controllers/diaryTagController.js
================
const DiaryEntry = require('../models/DiaryModel');
const Tag = require('../models/TagModel');
const io = require('../index'); // Импортируем `io`

const fs = require('fs'); // Импортируем `io`
const mongoose = require('mongoose');

exports.getAllTags = async (req, res) => {
    try {
        const tags = await Tag.find();
        res.status(200).json(tags);
    } catch (err) {
        res.status(500).json({ message: err.message });
    }
};

exports.createDiaryTag = async (req, res) => {
    try {
        const entryId = req.params.id;
        const { name } = req.body;

        // Проверяем, существует ли заметка
        const entry = await DiaryEntry.findById(entryId);
        if (!entry) {
            return res.status(404).json({ message: 'Entry not found' });
        }

        // Проверяем, существует ли тег с похожим названием
        const existingTag = await Tag.findOne({ name: { $regex: new RegExp(`^${name}$`, 'i') } });

        if (existingTag) {
            entry.tags.push(existingTag._id);
            await entry.save();
            return res.status(200).json({ message: 'Tag with similar name already exists', tag: existingTag });
        }
        exports.createTag = async (req, res) => {
            try {
                const { name, entryId } = req.body;

                // Проверяем, существует ли тег с похожим названием
                const existingTag = await Tag.findOne({ name: { $regex: new RegExp(`^${name}$`, 'i') } });

                if (existingTag) {
                    // Если тег существует, добавляем его к заметке
                    const entry = await DiaryEntry.findById(entryId);
                    if (!entry) {
                        return res.status(404).json({ message: 'Entry not found' });
                    }
                    if (!entry.tags.includes(existingTag._id)) {
                        entry.tags.push(existingTag._id);
                        await entry.save();
                    }
                    return res.status(200).json({ message: 'Tag already exists', tag: existingTag });
                }

                // Создаем новый тег
                const newTag = new Tag({ name });
                await newTag.save();

                // Добавляем новый тег к заметке
                const entry = await DiaryEntry.findById(entryId);
                if (!entry) {
                    return res.status(404).json({ message: 'Entry not found' });
                }
                entry.tags.push(newTag._id);
                await entry.save();

                res.status(201).json({ message: 'Tag created and added to entry successfully', tag: newTag });
            } catch (err) {
                res.status(500).json({ message: err.message });
            }
        };

        // Создаем новый тег
        const tag = new Tag({ name: name });
        await tag.save();

        // Добавляем тег к заметке
        entry.tags.push(tag._id);
        await entry.save();

        res.status(201).json({ message: 'Tag created and added to entry successfully', tag });
    } catch (err) {
        res.status(500).json({ message: err.message });
    }
};

exports.deleteDiaryTag = async (req, res) => {
    try {
        const entryId = req.params.id;
        const { tagId } = req.body;

        // Находим заметку
        const entry = await DiaryEntry.findById(entryId);
        if (!entry) {
            return res.status(404).json({ message: 'Entry not found' });
        }

        // Удаляем тег из массива заметки
        entry.tags = entry.tags.filter((tag) => tag.toString() !== tagId);
        await entry.save();

        // Проверяем, используется ли тег в других заметках
        const tagUsageCount = await DiaryEntry.countDocuments({ tags: tagId });

        if (tagUsageCount === 0) {
            // Если тег больше нигде не используется, удаляем его из базы данных
            await Tag.findByIdAndDelete(tagId);
            res.status(200).json({ message: 'Tag removed from entry and deleted from database' });
        } else {
            res.status(200).json({ message: 'Tag removed from entry' });
        }
    } catch (err) {
        res.status(500).json({ message: err.message });
    }
};

exports.createTag = async (req, res) => {
    try {
        const { name, entryId } = req.body;

        // Проверяем, является ли entryId допустимым ObjectId
        if (!mongoose.Types.ObjectId.isValid(entryId)) {
            return res.status(400).json({ message: 'Invalid entryId' });
        }

        // Проверяем, существует ли тег с похожим названием
        const existingTag = await Tag.findOne({ name: { $regex: new RegExp(`^${name}$`, 'i') } });

        if (existingTag) {
            // Если тег существует, добавляем его к заметке
            const entry = await DiaryEntry.findById(entryId);
            if (!entry) {
                return res.status(404).json({ message: 'Entry not found' });
            }
            if (!entry.tags.includes(existingTag._id)) {
                entry.tags.push(existingTag._id);
                await entry.save();
            }
            return res.status(200).json({ message: 'Filter already exists', tag: existingTag });
        }

        // Создаем новый тег
        const newTag = new Tag({ name });
        await newTag.save();

        // Добавляем новый тег к заметке
        const entry = await DiaryEntry.findById(entryId);
        if (!entry) {
            return res.status(404).json({ message: 'Entry not found' });
        }
        entry.tags.push(newTag._id);
        await entry.save();

        res.status(201).json({ message: 'Filter created and added to entry successfully', tag: newTag });
    } catch (err) {
        res.status(500).json({ message: err.message, stack: err.stack });
    }
};

================
File: index.js
================
const express = require('express');
const mongoose = require('mongoose');
const bodyParser = require('body-parser');
const cors = require('cors');
const http = require('http');
const morgan = require('morgan');
const path = require('path');
const fs = require('fs').promises;

const app = express();
const port = process.env.PORT || 3500;

app.use(cors());
app.use(bodyParser.json());
app.use(morgan('dev'));

const server = http.createServer(app);
const io = require('socket.io')(server, {
    cors: {
        origin: '*',
    },
});

mongoose
    .connect('mongodb://localhost:27017/diary', {
        useNewUrlParser: true,
        useUnifiedTopology: true,
    })
    .then(() => console.log('Connected to MongoDB'))
    .catch((err) => console.error('Could not connect to MongoDB', err));

io.on('connection', (socket) => {
    socket.on('disconnect', () => {
        // console.log('Client disconnected');
    });
});

module.exports = io;

app.use('/uploads', express.static(path.join(__dirname, 'uploads')));

// Routes
const diaryEntriesRoutes = require('./routes/diaryEntries');
const diaryFiltersRoutes = require('./routes/diaryFilters');
app.use('/api/diaryEntries', diaryEntriesRoutes);
app.use('/api/diaryFilters', diaryFiltersRoutes);

// Инициализация Telegram бота
const initBot = require('./botTelegram/telegramBot');
initBot();

// Import upload middleware and handlers
const upload = require('./upload');
const { processDatabaseFile } = require('./uploadHandlers');

// Обработка загрузки файла reword
app.post('/upload', upload.single('file'), async (req, res) => {
    if (!req.file || !req.body.format) {
        return res.status(400).send('No file or format specified.');
    }

    const filePath = path.join(__dirname, 'uploads', req.file.filename);
    const outputFormat = req.body.format;

    try {
        const result = await processDatabaseFile(filePath, outputFormat);

        res.setHeader('Content-Disposition', 'attachment; filename=exported_words.txt');
        res.setHeader('Content-Type', 'text/plain');
        res.send(result);
    } catch (error) {
        res.status(500).send('Error processing file.');
    } finally {
        try {
            await fs.unlink(filePath);
        } catch (unlinkError) {
            console.error('Error deleting file:', unlinkError);
        }
    }
});

server.listen(port, () => {
    console.log(`Server is running on port ${port}`);
});

================
File: models/DiaryModel.js
================
// models/DiaryModel.js
const mongoose = require('mongoose');
const { FLAT_SOURCE_TYPES } = require('./sourceTypes');

const WeatherInfoSchema = new mongoose.Schema({
    date: Date,
    mainCondition: String,
    description: String,
    iconId: String,
    conditionId: Number,
    temperature: Number,
    sunrise: Date,
    sunset: Date,
    cloudiness: Number,
    windSpeed: Number,
    windDirection: Number,
});

const LocationSchema = new mongoose.Schema({
    address: String,
    latitude: Number,
    longitude: Number,
    dateCreated: Date,
});

const ImageSchema = new mongoose.Schema(
    {
        path: String,
        fileName: String,
        dateAdded: Date,
        diaryEntryId: Number,
        isHeaderImage: Boolean,
    },
    { _id: true }
);

const ForwardOriginSchema = new mongoose.Schema({
    type: {
        type: String,
        enum: FLAT_SOURCE_TYPES,
        required: true,
    },
    subtype: {
        type: String,
        enum: FLAT_SOURCE_TYPES,
        required: false,
    },
    title: String,
    username: String,
    firstName: String,
    lastName: String,
    isHidden: Boolean,
    channelId: String,
    userId: String,
});

const DiaryEntrySchema = new mongoose.Schema({
    title: String,
    content: String,
    createdAt: Date,
    diaryDate: Date,
    weatherInfo: { type: WeatherInfoSchema, required: false },
    createdAtLocation: { type: LocationSchema, required: false },
    images: [ImageSchema],
    tags: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Tag' }], // Ссылки на теги
    forward_origin: ForwardOriginSchema,
});

module.exports = mongoose.model('DiaryEntry', DiaryEntrySchema);

================
File: models/sourceTypes.js
================
// sourceTypes.js (общий файл для фронтенда и бэкенда)

const SOURCE_TYPES = {
    TELEGRAM: 'telegram',
    DIARY: 'diary',
    EDITOR: 'editor',
};

const SOURCE_SUBTYPES = {
    [SOURCE_TYPES.TELEGRAM]: ['channel', 'user', 'hidden_user'],
    [SOURCE_TYPES.DIARY]: ['diary'],
    [SOURCE_TYPES.EDITOR]: ['editor'],
};

// Это массив, который включает в себя все типы и подтипы в одном уровне:
// [
//     'telegram', 'channel', 'user', 'hidden_user',
//     'diary', 'diary',
//     'editor', 'editor'
// ]

const FLAT_SOURCE_TYPES = Object.values(SOURCE_TYPES).reduce((acc, type) => {
    return [...acc, type, ...SOURCE_SUBTYPES[type]];
}, []);

module.exports = {
    SOURCE_TYPES,
    SOURCE_SUBTYPES,
    FLAT_SOURCE_TYPES,
};

================
File: models/TagModel.js
================
// models/TagModel.js
const mongoose = require('mongoose');

const TagSchema = new mongoose.Schema({
    name: { type: String, unique: true, required: true },
    createdAt: { type: Date, default: Date.now },
});

module.exports = mongoose.model('Tag', TagSchema);

================
File: package.json
================
{
    "dependencies": {
        "@faker-js/faker": "^8.4.1",
        "axios": "^1.7.2",
        "body-parser": "^1.20.2",
        "cors": "^2.8.5",
        "express": "^4.19.2",
        "mongoose": "^8.5.1",
        "morgan": "^1.10.0",
        "multer": "^1.4.5-lts.1",
        "node-telegram-bot-api": "^0.66.0",
        "nodemon": "^3.1.4",
        "socket.io": "^4.7.5",
        "sqlite3": "^5.1.7"
    },
    "scripts": {
        "dev": "nodemon index.js",
        "start": "node index.js"
    },
    "type": "commonjs"
}

================
File: routes/diaryEntries.js
================
const express = require('express');
const fs = require('fs');
const router = express.Router();
const diaryEntriesController = require('../controllers/diaryEntriesController');
const diaryTagController = require('../controllers/diaryTagController');
const upload = require('../upload');
const DiaryEntry = require('../models/DiaryModel');

router.get('/getAllDiaryEntries', diaryEntriesController.getAllDiaryEntries);
router.post('/getAvailableFilters', diaryEntriesController.getAvailableFilters);
router.get('/getDiaryDates', diaryEntriesController.getDiaryDates);
router.get('/:id', diaryEntriesController.getDiaryEntryById);
router.post('/createDiaryEntry', diaryEntriesController.createDiaryEntry);
router.put('/:id', diaryEntriesController.updateDiaryEntry);
router.delete('/:id', diaryEntriesController.deleteDiaryEntry);
// Загрузить изображения
router.post('/:id/images', upload.single('file'), diaryEntriesController.uploadImageEntry);
// Удалить изображение
router.delete('/:id/images/:imageId', diaryEntriesController.deleteImageEntry);

module.exports = router;

================
File: routes/diaryFilters.js
================
const diaryTagController = require('../controllers/diaryTagController');
const express = require('express');
const router = express.Router();

router.get('/getAllTags', diaryTagController.getAllTags);
router.post('/:id', diaryTagController.createDiaryTag);

router.delete('/:id', diaryTagController.deleteDiaryTag);
router.post('/create/tagfortg', diaryTagController.createTag);

module.exports = router;

================
File: upload.js
================
// upload.js
const multer = require('multer');
const path = require('path');

// Определяем место хранения файлов и имя файла
const storage = multer.diskStorage({
    destination: function (req, file, cb) {
        return cb(null, 'uploads/');
    },
    filename: function (req, file, cb) {
        return cb(null, `${Date.now()}_${file.originalname}`);
    },
});

const upload = multer({ storage });

module.exports = upload;

================
File: uploadHandlers.js
================
const path = require('path');
const fs = require('fs').promises;
const sqlite3 = require('sqlite3').verbose();

async function processDatabaseFile(filePath, format) {
    return new Promise((resolve, reject) => {
        const db = new sqlite3.Database(filePath, (err) => {
            if (err) {
                console.error('Error opening database:', err.message);
                reject(err);
            } else {
                console.log('Database opened successfully.');
                exportWords(db, format)
                    .then(resolve)
                    .catch(reject)
                    .finally(() => {
                        db.close((err) => {
                            if (err) {
                                console.error('Error closing database:', err.message);
                            } else {
                                console.log('Database closed.');
                            }
                        });
                    });
            }
        });
    });
}

async function exportWords(db, format) {
    try {
        const categories = await getTableData(db, 'CATEGORY');
        const wordCategories = await getTableData(db, 'WORD_CATEGORY');
        const words = await getTableData(db, 'WORD');

        const targetCategories = categories.filter((cat) => cat.NAME_RUS === 'books' || cat.NAME_RUS === 'Свои слова');
        const targetWordIds = wordCategories.filter((wc) => targetCategories.some((tc) => tc.ID === wc.CATEGORY_ID)).map((wc) => wc.WORD_ID);
        const targetWords = words
            .filter((word) => targetWordIds.includes(word.ID))
            .map((word) => ({
                word: word.WORD,
                translation: word.RUS,
            }));

        let outputContent;
        if (format === 'csv') {
            outputContent = targetWords.map((w) => w.word).join(', ');
        } else {
            outputContent = targetWords.map((w) => `${w.word} - ${w.translation}`).join('\n');
        }

        return outputContent;
    } catch (error) {
        console.error('Error occurred:', error);
        throw error;
    }
}

function getTableData(db, tableName) {
    return new Promise((resolve, reject) => {
        db.all(`SELECT * FROM ${tableName};`, [], (err, rows) => {
            if (err) {
                reject(err);
            } else {
                resolve(rows);
            }
        });
    });
}

module.exports = {
    processDatabaseFile,
};
