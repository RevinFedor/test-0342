================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-10-23T13:41:55.644Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
hooks/useChapter.ts
hooks/useChapterDuplicate.ts
hooks/useEPUB.ts
model/booksApiSlice.ts
model/types.ts
model/utils.ts
ui/BookReader.tsx
ui/ChaptersPopup.tsx
ui/PagedText.tsx

================================================================
Repository Files
================================================================

================
File: hooks/useChapter.ts
================
// hooks/useChapter.ts
import { useState, useEffect } from 'react';
import JSZip from 'jszip';
import DOMPurify from 'dompurify';
import { getFullImagePath } from '../model/utils';

interface UseChapterProps {
    bookFile: ArrayBuffer | null;
    href: string;
    knownChapterTitles: any;
    images: Record<string, string>;
}

interface HeadingInfo {
    tag: string;
    text: string;
    index: number;
}

/**
 * Computes the Levenshtein distance between two strings.
 * @param a First string
 * @param b Second string
 * @returns Levenshtein distance
 */
export const levenshteinDistance = (a: string, b: string): number => {
    const an = a ? a.length : 0;
    const bn = b ? b.length : 0;
    if (an === 0) return bn;
    if (bn === 0) return an;
    const matrix = new Array<number[]>(bn + 1);
    for (let i = 0; i <= bn; ++i) {
        const row = (matrix[i] = new Array<number>(an + 1));
        row[0] = i;
    }
    const firstRow = matrix[0];
    for (let j = 1; j <= an; ++j) {
        firstRow[j] = j;
    }
    for (let i = 1; i <= bn; ++i) {
        for (let j = 1; j <= an; ++j) {
            if (b.charAt(i - 1) === a.charAt(j - 1)) {
                matrix[i][j] = matrix[i - 1][j - 1];
            } else {
                const substitution = matrix[i - 1][j - 1] + 1;
                const insertion = matrix[i][j - 1] + 1;
                const deletion = matrix[i - 1][j] + 1;
                matrix[i][j] = Math.min(substitution, insertion, deletion);
            }
        }
    }
    return matrix[bn][an];
};

const useChapter = ({ bookFile, href, images, knownChapterTitles }: UseChapterProps) => {
    const [content, setContent] = useState<string | null>(null);
    const [error, setError] = useState<string | null>(null);
    const [headings, setHeadings] = useState<HeadingInfo[]>([]); // Новое состояние для заголовков

    useEffect(() => {
        if (!bookFile) {
            return;
        }
        const loadChapter = async () => {
            try {
                //! console.log('Loading chapter with href:', href);
                const zip = await JSZip.loadAsync(bookFile);
                const baseHref = href.split('#')[0];
                let chapterFile = zip.file(`OPS/${baseHref}`);
                if (!chapterFile) {
                    const availableFiles = Object.keys(zip.files);
                    const similarFile = availableFiles.find((file) => file.toLowerCase() === baseHref.toLowerCase());
                    if (similarFile) {
                        chapterFile = zip.file(similarFile);
                        console.warn(`Found a similar file name: ${similarFile}`);
                    } else {
                        throw new Error(`Chapter file not found: ${baseHref}`);
                    }
                }

                let contentFile = await chapterFile.async('string');
                contentFile = contentFile.replace(/<\?xml.*?\?>\s*/g, '');

                const parser = new DOMParser();
                const doc = parser.parseFromString(contentFile, 'application/xhtml+xml');
                const body = doc.body;

                if (body) {
                    const imagesInContent = body.querySelectorAll('img, image');
                    imagesInContent.forEach((imgElement) => {
                        const src = imgElement.getAttribute('src') || imgElement.getAttributeNS('http://www.w3.org/1999/xlink', 'href');
                        if (src) {
                            const imagePath = getFullImagePath(baseHref, src);
                            const imageUri = images[imagePath] || images[src];

                            if (imageUri) {
                                if (imgElement instanceof HTMLImageElement || imgElement instanceof SVGImageElement) {
                                    if (imgElement instanceof HTMLImageElement) {
                                        imgElement.setAttribute('src', imageUri);
                                    } else {
                                        imgElement.setAttributeNS('http://www.w3.org/1999/xlink', 'href', imageUri);
                                    }

                                    imgElement.style.display = 'block';
                                    imgElement.style.marginLeft = 'auto';
                                    imgElement.style.marginRight = 'auto';
                                    imgElement.style.maxWidth = '100%';
                                    imgElement.style.height = 'auto';
                                }
                            } else {
                                console.warn(`Image not found: ${src}`);
                            }
                        }
                    });

                    //! логи на добавление аттрибудто заголовка и парсинга
                    //! вся нагрузка тут
                    extractAndLogHeadings(doc.body, knownChapterTitles);

                    setContent(doc.body.outerHTML);
                } else {
                    throw new Error('The <body> tag was not found in the chapter content.');
                }
            } catch (err: any) {
                console.error('Error loading chapter content:', err);
                setError(err.message);
            }
        };

        if (bookFile && href) {
            loadChapter();
        }

    }, [href, bookFile, images]);


    /**
     * Function to extract headings from the DOM and log them.
     * @param body DOM element <body>
     * @param knownChapterTitles List of known chapter titles
     */
    const extractAndLogHeadings = (body: HTMLElement, knownChapterTitles: string[]) => {
        const candidateHeadings: HeadingInfo[] = [];
        let index = 0;

        const normalizeText = (text: string): string => {
            return text
                .replace(/\s+/g, ' ') // Replace multiple whitespace with single space
                .replace(/[\n\r]/g, ' ') // Remove line breaks
                .replace(/&nbsp;/g, ' ') // Replace HTML non-breaking spaces
                .trim()
                .toLowerCase();
        };

        const knownTitlesNormalized = knownChapterTitles.map(normalizeText);

        // Traverse the DOM to find potential headings
        const traverseDom = (element: Element) => {
            const textContent = element.textContent?.trim() || '';
            if (textContent.length > 0) {
                const normalizedText = normalizeText(textContent);

                for (const [i, chapterTitle] of knownTitlesNormalized.entries()) {
                    // Calculate similarity score
                    const similarity = calculateSimilarity(normalizedText, chapterTitle);

                    // Set a threshold for considering a match (e.g., similarity > 0.7)
                    if (similarity > 0.7) {
                        candidateHeadings.push({
                            tag: element.tagName,
                            text: textContent,
                            index: index++,
                            similarity,
                        });

                        //! чет он не хочется пушить
                        element.setAttribute('data-chapter-title', knownChapterTitles[i]);

                        break; // Stop checking other chapter titles for this element
                    }
                }
            }

            // Recurse on child elements
            Array.from(element.children).forEach((child) => traverseDom(child));
        };

        traverseDom(body);

        // Now, filter the candidate headings to keep only the best match
        if (candidateHeadings.length > 0) {
            // Sort candidates by similarity descending
            candidateHeadings.sort((a, b) => b.similarity - a.similarity);

            // Keep only the top candidate(s) with highest similarity
            const maxSimilarity = candidateHeadings[0].similarity;
            const bestHeadings = candidateHeadings.filter((h) => h.similarity === maxSimilarity);

            setHeadings(bestHeadings);
            console.log('Extracted Headings:', bestHeadings);
        } else {
            setHeadings([]);
            console.log('No matching headings found.');
        }
    };

    /**
     * Calculates similarity between two strings using normalized Levenshtein distance.
     * @param a First string
     * @param b Second string
     * @returns Similarity score between 0 and 1
     */
    const calculateSimilarity = (a: string, b: string): number => {
        const distance = levenshteinDistance(a, b);
        const maxLen = Math.max(a.length, b.length);
        return maxLen === 0 ? 1 : 1 - distance / maxLen;
    };

    return { content, error, headings };
};

export default useChapter;

================
File: hooks/useChapterDuplicate.ts
================
// src/features/bookReader/hooks/useChapterDuplicate.ts

import { useState, useEffect } from 'react';
import { loadChapterContent, computeHash, flattenChapters } from '../model/utils';
import { Chapter } from '../model/types';


/**
 * Интерфейс для входных параметров хука useChapterDuplicate.
 */
interface useChapterDuplicateProps {
    bookFile: ArrayBuffer | null;
    chapters: Chapter[];
}

/**
 * Интерфейс для выходных данных хука useChapterDuplicate.
 */
interface useChapterDuplicateReturn {
    duplicates: Record<string, string[]>; // хеш и список href
    loading: boolean;
    error: string | null;
}

/**
 * Хук useChapterDuplicate находит дублирующиеся главы на основе содержимого.
 * @param bookFile - EPUB файл как ArrayBuffer
 * @param chapters - список глав
 * @returns { duplicates, loading, error }
 */
const useChapterDuplicate = ({ bookFile, chapters }: useChapterDuplicateProps): useChapterDuplicateReturn => {
    const [duplicates, setDuplicates] = useState<Record<string, string[]>>({});
    const [loading, setLoading] = useState<boolean>(false);
    const [error, setError] = useState<string | null>(null);

    useEffect(() => {
        const findDuplicates = async () => {
            if (!bookFile || chapters.length === 0) {
                setError('EPUB файл или список глав не предоставлены.');
                return;
            }

            setLoading(true);
            setError(null);

            try {
                const flatChapters = flattenChapters(chapters);
                const hashMap: Record<string, string[]> = {};

                for (const chapter of flatChapters) {
                    const href = chapter.href;
                    const content = await loadChapterContent(bookFile, href);
                    if (content) {
                        const hash = await computeHash(content);
                        if (hashMap[hash]) {
                            hashMap[hash].push(href);
                        } else {
                            hashMap[hash] = [href];
                        }
                    } else {
                        console.warn(`Содержимое главы не загружено: ${href}`);
                    }
                }

                // Фильтруем только те хеши, у которых более одной главы
                const duplicatesFound: Record<string, string[]> = {};
                Object.entries(hashMap).forEach(([hash, hrefs]) => {
                    if (hrefs.length > 1) {
                        duplicatesFound[hash] = hrefs;
                    }
                });

                setDuplicates(duplicatesFound);

                // if (Object.keys(duplicatesFound).length === 0) {
                //     console.log('Дублирующиеся главы не найдены.');
                // } else {
                //     console.log('Найдены дублирующиеся главы:', duplicatesFound);
                // }
            } catch (err: any) {
                console.error('Ошибка при поиске дублирующихся глав:', err);
                setError(err.message || 'Неизвестная ошибка');
            } finally {
                setLoading(false);
            }
        };

        findDuplicates();
    }, [bookFile, chapters]);

    return { duplicates, loading, error };
};

export default useChapterDuplicate;

================
File: hooks/useEPUB.ts
================
// src/features/bookReader/hooks/useEPUB.ts
import { useState, useEffect } from 'react';
import JSZip from 'jszip';
import DOMPurify from 'dompurify';
import { parseNavPoints, getFullImagePath } from '../model/utils'; // Вынесите функции в shared/utils
import { Chapter } from '../model/types';

const useEPUB = (bookFile: Blob | null) => {
    const [chapters, setChapters] = useState<Chapter[]>([]);
    const [cssContent, setCssContent] = useState<string>('');
    const [images, setImages] = useState<Record<string, string>>({});
    const [error, setError] = useState<string | null>(null);

    useEffect(() => {

        
        const loadEpub = async () => {
            if (bookFile) {
                try {
                    const zip = await JSZip.loadAsync(bookFile);

                    // Загрузка TOC
                    const tocFile = zip.file(/toc\.ncx$/i)[0];
                    if (!tocFile) throw new Error('toc.ncx не найден');

                    const tocContent = await tocFile.async('string');
                    const parser = new DOMParser();
                    const tocDoc = parser.parseFromString(tocContent, 'application/xml');
                    const rootNavPoints = tocDoc.querySelectorAll('navMap > navPoint');
                    const newChapters = parseNavPoints(rootNavPoints);
                    setChapters(newChapters);

                    // Загрузка CSS
                    const cssFiles = Array.from(zip.file(/.*\.css$/i));
                    const cssContents = await Promise.all(cssFiles.map((file) => file.async('string')));
                    setCssContent(cssContents.join('\n'));

                    // Загрузка изображений
                    const imageFiles = Array.from(zip.file(/\.(png|jpg|jpeg|gif|svg)$/i));
                    const imageMap: Record<string, string> = {};
                    await Promise.all(
                        imageFiles.map(async (file) => {
                            const data = await file.async('base64');
                            const extensionMatch = file.name.match(/\.(png|jpg|jpeg|gif|svg)$/i);
                            const extension = extensionMatch ? extensionMatch[1].toLowerCase() : 'png';
                            const mimeType = extension === 'svg' ? 'image/svg+xml' : `image/${extension === 'jpg' ? 'jpeg' : extension}`;
                            const dataUri = `data:${mimeType};base64,${data}`;
                            imageMap[file.name] = dataUri;
                        })
                    );

                    setImages(imageMap);
                } catch (err) {
                    console.error('Ошибка при загрузке EPUB:', err);
                    setError(err.message);
                }
            }
        };

        loadEpub();
    }, [bookFile]);

    return { chapters, cssContent, images, error };
};

export default useEPUB;

================
File: model/booksApiSlice.ts
================
import { api } from '@/app/api/apiSlice';
import JSZip from 'jszip';

export interface Book {
    _id: string;
    filePath: string;
    title?: string;
    creator?: string;
    description?: string;
}

export interface ParsedBook extends Omit<Book, '_id'> {
    title: string;
    creator: string;
    description: string;
    content: ArrayBuffer;
}

export const booksApi = api.injectEndpoints({
    endpoints: (builder) => ({
        getBooks: builder.query<Book[], void>({
            query: () => 'books',
            providesTags: ['Books'],
        }),
        getBookById: builder.query<ArrayBuffer, string>({
            query: (id) => ({
                url: `http://localhost:3500/api/books/${id}`,
                responseHandler: (response) => response.arrayBuffer(), // Обработка ответа как ArrayBuffer
            }),
        }),

        getBookContent: builder.query<ParsedBook, string>({
            query: (filePath) => ({
                url: 'http://localhost:3500' + filePath,
                responseHandler: (response) => response.arrayBuffer(),
            }),
            transformResponse: async (content: ArrayBuffer, _, filePath) => {
                const zip = await JSZip.loadAsync(content);
                const metadataFile = zip.file('OEBPS/content.opf') || zip.file('content.opf');
                const metadataContent = metadataFile ? await metadataFile.async('text') : '';

                const parser = new DOMParser();
                const metadataDoc = parser.parseFromString(metadataContent, 'application/xml');
                const title = metadataDoc.querySelector('title')?.textContent || 'Unknown Title';
                const creator = metadataDoc.querySelector('creator')?.textContent || 'Unknown Author';
                const description = metadataDoc.querySelector('description')?.textContent || 'No description available';

                return {
                    title,
                    creator,
                    description,
                    content,
                    filePath,
                };
            },
        }),
        uploadBook: builder.mutation<void, FormData>({
            query: (formData) => ({
                url: 'books',
                method: 'POST',
                body: formData,
            }),
            invalidatesTags: ['Books'],
        }),
        deleteBook: builder.mutation<void, string>({
            query: (id) => ({
                url: `books/${id}`,
                method: 'DELETE',
            }),
            invalidatesTags: ['Books'],
        }),
    }),
});

export const { useGetBooksQuery, useUploadBookMutation, useDeleteBookMutation, useGetBookByIdQuery, useGetBookContentQuery } = booksApi;

================
File: model/types.ts
================
export interface Chapter {
    label: string;
    href: string;
    cfi: string; // CFI можно вычислить позже, если потребуется
    level: number; // Представляет уровень вложенности
    children?: Chapter[];
    
}

================
File: model/utils.ts
================
// src/shared/utils/epubUtils.ts
import JSZip from 'jszip';
import { Chapter } from './types';
import DOMPurify from 'dompurify';

export const parseNavPoints = (navPoints: NodeListOf<Element>, currentLevel: number = 1): Chapter[] => {
    const chapters: Chapter[] = [];

    navPoints.forEach((navPoint) => {
        const label = navPoint.querySelector('navLabel > text')?.textContent || 'Глава';
        const href = navPoint.querySelector('content')?.getAttribute('src') || '';

        const chapter: Chapter = {
            label,
            href,
            cfi: '',
            level: currentLevel,
            children: [],
        };

        const childNavPoints = navPoint.querySelectorAll(':scope > navPoint');
        if (childNavPoints.length > 0) {
            chapter.children = parseNavPoints(childNavPoints, currentLevel + 1);
        }

        chapters.push(chapter);
    });

    return chapters;
};

export const getFullImagePath = (baseHref: string, src: string): string => {
    // If the src is already an absolute path like 'OPS/images/...'
    if (src.startsWith('OPS/')) {
        return src;
    }

    // If the src is relative, ensure that 'OPS/' is prepended if it's missing
    const chapterPath = baseHref.substring(0, baseHref.lastIndexOf('/') + 1);
    const fullPath = chapterPath + src;

    if (!fullPath.startsWith('OPS/')) {
        return 'OPS/' + fullPath;
    }

    return fullPath;
};

/**
 * Хелпер-функция для разворачивания иерархии глав.
 * @param chapters - список глав
 * @returns плоский список глав
 */
export const flattenChapters = (chapters: Chapter[]): Chapter[] => {
    const flat: Chapter[] = [];
    const traverse = (chapterList: Chapter[]) => {
        chapterList.forEach((chapter) => {
            flat.push(chapter);
            if (chapter.children && chapter.children.length > 0) {
                traverse(chapter.children);
            }
        });
    };
    traverse(chapters);
    return flat;
};

//! Функция для получения всех родительских глав до третьего или четвертого уровня
export const getParentChapters = (chapters: Chapter[], href: string): Chapter[] => {
    const parents: Chapter[] = [];

    const findChapter = (chapterList: Chapter[], currentHref: string, ancestors: Chapter[] = []): boolean => {
        for (const chapter of chapterList) {
            const newAncestors = [...ancestors, chapter];
            if (chapter.href === currentHref) {
                // Добавляем найденных родителей
                parents.push(...newAncestors);
                return true;
            }

            // Если у главы есть вложенные, ищем в них
            if (chapter.children && chapter.children.length > 0) {
                const found = findChapter(chapter.children, currentHref, newAncestors);
                if (found) {
                    return true;
                }
            }
        }
        return false;
    };

    findChapter(chapters, href);
    return parents;
};

//! ++++++++++++++++++++++
/**
 * Получает базовый href, удаляя фрагмент.
 * @param href - полный href с фрагментом
 * @returns базовый href без фрагмента
 */
export const getBaseHref = (href: string): string => {
    const [baseHref] = href.split('#');
    return baseHref;
};

/**
 * Загружает содержимое главы по href.
 * @param bookFile - EPUB файл как ArrayBuffer
 * @param href - href главы
 * @returns содержимое главы как строка или null в случае ошибки
 */
export const loadChapterContent = async (bookFile: ArrayBuffer, href: string): Promise<string | null> => {
    try {
        const zip = await JSZip.loadAsync(bookFile);
        const baseHref = getBaseHref(href);
        let chapterFile = zip.file(`OPS/${baseHref}`);

        if (!chapterFile) {
            const availableFiles = Object.keys(zip.files);
            const similarFile = availableFiles.find((file) => file.toLowerCase() === baseHref.toLowerCase());
            if (similarFile) {
                chapterFile = zip.file(similarFile);
            } else {
                return null;
            }
        }

        let chapterContent = await chapterFile.async('string');
        // Удаляем XML декларацию, если она есть
        chapterContent = chapterContent.replace(/<\?xml.*?\?>\s*/g, '');

        // Очищаем содержимое с помощью DOMPurify
        const parser = new DOMParser();
        const doc = parser.parseFromString(chapterContent, 'application/xhtml+xml');
        const body = doc.body;

        if (!body) {
            console.warn('Тег <body> не найден в содержимом главы.');
            return null;
        }

        // Сериализуем содержимое <body>
        const serializer = new XMLSerializer();
        let sanitizedContent = serializer.serializeToString(body);
        sanitizedContent = DOMPurify.sanitize(sanitizedContent);
        return sanitizedContent;
    } catch (err) {
        console.error('Ошибка при загрузке содержимого главы:', err);
        return null;
    }
};

/**
 * Вычисляет SHA-256 хеш для заданной строки.
 * @param content - содержимое главы
 * @returns хеш в формате hex
 */
export const computeHash = async (content: string): Promise<string> => {
    const encoder = new TextEncoder();
    const data = encoder.encode(content);
    const hashBuffer = await crypto.subtle.digest('SHA-256', data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map((b) => b.toString(16).padStart(2, '0')).join('');
    return hashHex;
};

================
File: ui/BookReader.tsx
================
import React, { useEffect, useState, useRef } from 'react';
import { useParams } from 'react-router-dom';
import { useGetBookByIdQuery } from '../model/booksApiSlice';
import { ArrowLeft, ArrowRight, Loader2 } from 'lucide-react';

import { ChaptersPopup } from './ChaptersPopup';
import useChapter from '../hooks/useChapter';
import useEPUB from '../hooks/useEPUB';
import PagedText from './PagedText';
import { flattenChapters, getParentChapters } from '../model/utils';
import useChapterDuplicate from '../hooks/useChapterDuplicate';

const extractChapterTitles = (chapters) => {
    const titles = [];

    const extractTitlesRecursively = (chapterList) => {
        chapterList.forEach((chapter) => {
            titles.push(chapter.label); // Добавляем заголовок текущего уровня
            if (chapter.children && chapter.children.length > 0) {
                extractTitlesRecursively(chapter.children); // Рекурсивно обрабатываем дочерние элементы
            }
        });
    };

    extractTitlesRecursively(chapters);

    return titles;
};

const BookReader: React.FC = () => {
    const { id } = useParams<{ id: string }>();
    const [currentChapter, setCurrentChapter] = useState<string>(null);
    const [isScrollingInPopup, setIsScrollingInPopup] = useState(false);
    const [knownChapterTitles, setKnownChapterTitles] = useState<string[]>([]); // State to store chapter titles

    const { data: bookFile, isLoading: isLoadingContent, error } = useGetBookByIdQuery(id);
    const { chapters, cssContent, images } = useEPUB(bookFile);

    useEffect(() => {
        if (chapters.length > 0 && !currentChapter) {
            setCurrentChapter(chapters[0].href);
        }
    }, [chapters, currentChapter]);

    //! Call extractChapterTitles only once on initial load
    useEffect(() => {
        if (chapters.length > 0) {
            setKnownChapterTitles(extractChapterTitles(chapters)); // Set titles once
        }
    }, [chapters]); // Empty dependency array ensures this runs only once

    const { content, headings } = useChapter({
        bookFile,
        href: currentChapter,
        images,
        knownChapterTitles, // Pass known chapter titles
    });

    // Function to handle heading encountered
    const handleHeadingEncountered = (chapterTitle: string) => {
        const flatChapters = flattenChapters(chapters);
        const chapter = flatChapters.find((ch) => ch.label === chapterTitle);
        if (chapter && chapter.href !== currentChapter) {
            setCurrentChapter(chapter.href);
        }
    };

    //! Используем хук для поиска дублирующихся глав
    const {
        duplicates,
        loading: isLoadingDuplicates,
        error: duplicatesError,
    } = useChapterDuplicate({
        bookFile,
        chapters,
    });

    //! настройка скролла для popup оглавления
    const handleWheel = (event: WheelEvent) => {
        if (!isScrollingInPopup) {
            if (event.deltaY < 0) {
            } else if (event.deltaY > 0) {
            }
        }
    };

    useEffect(() => {
        window.addEventListener('wheel', handleWheel);

        return () => {
            window.removeEventListener('wheel', handleWheel);
        };
    }, [isScrollingInPopup]);

    //!логика переключения глав

    // Логика переключения глав с учётом вложенности
    const handleNext = () => {
        const flatChapters = flattenChapters(chapters); // Все главы в одном массиве
        const currentChapterIndex = flatChapters.findIndex((ch) => ch.href === currentChapter);

        if (currentChapterIndex !== -1 && currentChapterIndex < flatChapters.length - 1) {
            setCurrentChapter(flatChapters[currentChapterIndex + 1].href);
        }
    };

    const handlePrev = () => {
        const flatChapters = flattenChapters(chapters); // Все главы в одном массиве
        const currentChapterIndex = flatChapters.findIndex((ch) => ch.href === currentChapter);

        if (currentChapterIndex > 0) {
            setCurrentChapter(flatChapters[currentChapterIndex - 1].href);
        }
    };

    const parentChapters = getParentChapters(chapters, currentChapter || '');

    if (isLoadingContent) {
        return <Loader2 />;
    }

    if (error) {
        return <div>Error loading book: {error?.message}</div>;
    }

    return (
        <div className="book-reader" style={{ position: 'relative' }}>
            {/* Внедрение CSS-стилей */}
            {cssContent && <style>{cssContent} </style>}

            {/* Всплывающее окно с оглавлением */}
            <ChaptersPopup
                mockChapters={chapters}
                currentChapter={currentChapter}
                setCurrentChapter={setCurrentChapter}
                setIsScrollingInPopup={setIsScrollingInPopup} // Передаем управление скроллом
            />

            <div className="page-navigation flex justify-center mb-2 relative">
                <button onClick={handlePrev} disabled={!currentChapter} className="nav-button absolute top-7 right-[50%]">
                    <ArrowLeft />
                </button>
                {/* Отображение текущей главы */}
                <div className="current-chapter-title text-[12px] font-bold" style={{ margin: '0 20px', textAlign: 'center' }}>
                    {parentChapters.map((chapter, index) => (
                        <span key={index}>
                            {chapter.label} {index < parentChapters.length - 1 ? ' » ' : ''} {chapter.href}
                        </span>
                    ))}
                </div>
                <button onClick={handleNext} disabled={!currentChapter} className="nav-button absolute top-7 left-[50%]">
                    <ArrowRight />
                </button>
            </div>

            {/* Основное содержимое книги */}
            <PagedText
                text={content}
                onHeadingEncountered={handleHeadingEncountered} // Pass the handler
            />
        </div>
    );
};

export default BookReader;

================
File: ui/ChaptersPopup.tsx
================
import { useState } from 'react';
import { ChevronRight, ChevronDown, AlignLeft } from 'lucide-react';
import { Popover, PopoverContent, PopoverTrigger } from '@/shared/ui/components/ui/popover';

interface Chapter {
    label: string;
    href: string;
    cfi: string;
    level: number;
    children?: Chapter[];
}

interface ChaptersPopupProps {
    mockChapters: Chapter[];
    currentChapter: string;
    setCurrentChapter: (href: string) => void;
    setIsScrollingInPopup: (isScrolling: boolean) => void; // Новый пропс для передачи состояния скролла
}

export const ChaptersPopup = ({ mockChapters, currentChapter, setCurrentChapter, setIsScrollingInPopup }: ChaptersPopupProps) => {
    const [expandedChapters, setExpandedChapters] = useState<Set<string>>(new Set());


    const toggleChapter = (href: string) => {
        setExpandedChapters((prev) => {
            const newSet = new Set(prev);
            if (newSet.has(href)) {
                newSet.delete(href);
            } else {
                newSet.add(href);
            }
            return newSet;
        });
    };

    const handleScroll = () => {
        setIsScrollingInPopup(true);
    };

    const handleMouseLeave = () => {
        setIsScrollingInPopup(false);
    };

    const renderChapter = (chapter: Chapter, parentExpanded: boolean = true) => {
        const isExpanded = expandedChapters.has(chapter.href);
        const hasChildren = chapter.children && chapter.children.length > 0;

        if (!parentExpanded && chapter.level !== 1) return null;

        return (
            <div key={chapter.href} className="w-full">
                <div
                    onClick={() => setCurrentChapter(chapter.href)}
                    className={`flex items-center p-2 cursor-pointer hover:bg-slate-100 ${currentChapter === chapter.href ? 'bg-slate-200' : ''}`}
                    style={{
                        paddingLeft: `${chapter.level * 12}px`,
                    }}
                >
                    {hasChildren ? (
                        <button
                            onClick={(e) => {
                                e.stopPropagation();
                                toggleChapter(chapter.href);
                            }}
                            className="mr-2 flex items-center justify-center w-4 h-4 focus:outline-none"
                            aria-expanded={isExpanded}
                            aria-label={isExpanded ? 'Свернуть раздел' : 'Развернуть раздел'}
                        >
                            {isExpanded ? <ChevronDown className="w-4 h-4 flex-shrink-0" /> : <ChevronRight className="w-4 h-4 flex-shrink-0" />}
                        </button>
                    ) : (
                        // Заполнитель для выравнивания
                        <span className="mr-2 w-4 h-4 inline-block"></span>
                    )}
                    <span className="truncate">{chapter.label}</span>
                </div>
                {isExpanded && hasChildren && <div>{chapter.children!.map((subChapter) => renderChapter(subChapter, isExpanded))}</div>}
            </div>
        );
    };

    return (
        <Popover>
            <PopoverTrigger>
                <AlignLeft className="ml-4" />
            </PopoverTrigger>
            <PopoverContent className="w-[400px] p-0">
                <div
                    className="h-[400px] overflow-y-auto overflow-x-hidden hide-scrollbar"
                    onScroll={handleScroll} // Отслеживаем скролл
                    onMouseLeave={handleMouseLeave} // Сброс состояния скролла при выходе мыши
                >
                    {mockChapters.map((chapter) => renderChapter(chapter))}
                </div>
            </PopoverContent>
        </Popover>
    );
};

================
File: ui/PagedText.tsx
================
import React, { useState, useEffect, useRef } from 'react';
import { ChevronLeft, ChevronRight } from 'lucide-react';
import { Button } from '@/shared/ui/components/ui/button';
import parse, { domToReact, HTMLReactParserOptions, Element as DomElement } from 'html-react-parser';

// Функция для преобразования строки стилей в объект
const parseStyle = (styleString: string): React.CSSProperties => {
    return styleString.split(';').reduce((style: React.CSSProperties, rule) => {
        const [key, value] = rule.split(':').map((item) => item.trim());
        if (key && value) {
            // Преобразование kebab-case в camelCase
            const camelCaseKey = key.replace(/-([a-z])/g, (g) => g[1].toUpperCase()) as keyof React.CSSProperties;
            style[camelCaseKey] = value;
        }
        return style;
    }, {});
};

//! функция для обработки изображений заранее
const waitForImages = (container: HTMLElement): Promise<void> => {
    const images = container.querySelectorAll('img');
    const promises = Array.from(images).map((img) => {
        if (img.complete) return Promise.resolve();
        return new Promise<void>((resolve) => {
            img.onload = resolve;
            img.onerror = resolve;
        });
    });
    return Promise.all(promises).then(() => {});
};

//! Рекурсивная функция для сбора всех элементов
const collectElements = (node: Node, elements: HTMLElement[]) => {
    if (node.nodeType === Node.ELEMENT_NODE) {
        const el = node as HTMLElement;
        // Собираем все блочные элементы
        if (['P', 'H1', 'H2', 'H3', 'IMG', 'DIV', 'FIGURE', 'SECTION', 'ARTICLE'].includes(el.tagName)) {
            elements.push(el);
            // Не рекурсивно обходим детей, если это блочный элемент
            return;
        }
        // Рекурсивно обходим детей для других типов элементов
        el.childNodes.forEach((child) => collectElements(child, elements));
    }
    // Игнорируем текстовые узлы и другие типы узлов
};

//! Функция для оценки высоты элемента
const estimateElementHeight = (el: HTMLElement): number => {
    // Создаём временный контейнер для измерения
    const tempContainer = document.createElement('div');
    tempContainer.style.visibility = 'hidden';
    tempContainer.style.position = 'absolute';
    tempContainer.style.top = '0';
    tempContainer.style.left = '0';
    tempContainer.style.width = '800px'; //! Убедитесь, что это соответствует реальной ширине столбца
    tempContainer.style.fontSize = '16px'; // Установите соответствующие стили
    tempContainer.style.lineHeight = '1.5'; // Установите соответствующие стили

    // Клонируем элемент для измерения
    const clone = el.cloneNode(true) as HTMLElement;

    // Для изображений задаём фиксированные размеры или получаем реальные
    if (clone.tagName === 'IMG') {
        const img = clone as HTMLImageElement;
        if (!img.height || img.height === 0) {
            // Задаём стандартную высоту, если не задана
            img.style.height = '200px';
        }
        // Устанавливаем ширину, чтобы соответствовать колонке
        img.style.width = '100%';
        img.style.objectFit = 'contain';
        img.style.display = 'block'; // Чтобы убрать пробелы снизу
    }

    tempContainer.appendChild(clone);
    document.body.appendChild(tempContainer);
    const height = tempContainer.offsetHeight;
    document.body.removeChild(tempContainer);
    return height;
};

interface PagedTextProps {
    text?: string;
    maxColumnHeight?: number; // Максимальная высота столбца в пикселях
}

interface Page {
    left: string;
    right: string;
}

export default function PagedText({ text = '', maxColumnHeight = 700, onHeadingEncountered }: PagedTextProps) {
    const [pages, setPages] = useState<Page[]>([]);
    const [pageHeadings, setPageHeadings] = useState<Record<number, string>>({});
    const [currentPage, setCurrentPage] = useState(0);
    const isSplittingRef = useRef(false); // Prevent duplicate splitting

    useEffect(() => {
        if (!text) {    
            setPages([]);
            return;
        }

        if (isSplittingRef.current) return;
        isSplittingRef.current = true;

        const splitHtmlIntoPages = async (html: string, maxHeight: number): Promise<{ pages: Page[]; pageHeadings: Record<number, string> }> => {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = html;

            // Wait for images to load
            await waitForImages(tempDiv);

            // Collect all elements
            const allElements: HTMLElement[] = [];

            
            tempDiv.childNodes.forEach((child) => collectElements(child, allElements));

            const pagesArray: Page[] = [];
            const pageHeadings: Record<number, string> = {};
            let currentPageContent: Page = { left: '', right: '' };
            let currentColumnHeight = [0, 0]; // [leftHeight, rightHeight]
            let currentColumn = 0; // 0 - left, 1 - right
            let currentPageIndex = 0;

            

            for (const element of allElements) {
                const elHeight = estimateElementHeight(element);

                if (elHeight > maxHeight) {
                    console.warn(`Element <${element.tagName.toLowerCase()}> exceeds max height and will be skipped.`);
                    continue;
                }

                if (currentColumnHeight[currentColumn] + elHeight > maxHeight) {
                    if (currentColumn === 0 && currentColumnHeight[1] === 0) {
                        currentColumn = 1;
                    } else {
                        pagesArray.push(currentPageContent);
                        currentPageContent = { left: '', right: '' };
                        currentColumnHeight = [0, 0];
                        currentColumn = 0;
                        currentPageIndex++;
                    }
                }


                
                // Check for data-chapter-title attribute
                if (element.hasAttribute('data-chapter-title')) {
                    const chapterTitle = element.getAttribute('data-chapter-title');
                    console.log(`Found heading on page ${currentPageIndex}: ${chapterTitle}`);
                    if (!pageHeadings[currentPageIndex]) {
                        pageHeadings[currentPageIndex] = chapterTitle!;
                    }
                } else{
                    console.log('Attribute not Found');
                    
                }

                // Add element to current column
                const htmlString = element.outerHTML || element.innerHTML || '';
                currentPageContent[currentColumn === 0 ? 'left' : 'right'] += htmlString;
                currentColumnHeight[currentColumn] += elHeight;
            }

            // Add the last page
            if (currentPageContent.left || currentPageContent.right) {
                pagesArray.push(currentPageContent);
            }

            return { pages: pagesArray, pageHeadings };
        };

        splitHtmlIntoPages(text, maxColumnHeight)
            .then(({ pages: pagesResult, pageHeadings: headingsResult }) => {
                setPages(pagesResult);
                setPageHeadings(headingsResult);
                setCurrentPage(0);
                isSplittingRef.current = false;
            })
            .catch((error) => {
                console.error('Error splitting content:', error);
                isSplittingRef.current = false;
            });
    }, [text, maxColumnHeight]);

    // Effect to detect page changes and notify about headings
    useEffect(() => {
        if (pageHeadings[currentPage]) {
            onHeadingEncountered(pageHeadings[currentPage]);
        }
    }, [currentPage, pageHeadings]);

    // Navigation functions
    const goToPreviousPage = () => {
        setCurrentPage((prev) => Math.max(0, prev - 1));
    };

    const goToNextPage = () => {
        setCurrentPage((prev) => Math.min(pages.length - 1, prev + 1));
    };

    if (pages.length === 0) {
        return <div className="text-center p-4">No text to display.</div>;
    }

    return (
        <div className="mx-auto p-10">
            <div className="flex justify-between items-center mb-4">
                <Button onClick={goToPreviousPage} disabled={currentPage === 0} variant="outline">
                    <ChevronLeft className="mr-2 h-4 w-4" /> Previous
                </Button>
                <span>
                    Page {currentPage + 1} of {pages.length}
                </span>
                <Button onClick={goToNextPage} disabled={currentPage === pages.length - 1} variant="outline">
                    Next <ChevronRight className="ml-2 h-4 w-4" />
                </Button>
            </div>
            {pages.length > 0 && (
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4 relative">
                    {/* Left Column */}
                    <div className="border px-4 rounded">{parse(pages[currentPage].left || '')}</div>
                    {/* Right Column */}
                    <div className="border px-4 rounded">{parse(pages[currentPage].right || '')}</div>
                </div>
            )}
        </div>
    );
}
