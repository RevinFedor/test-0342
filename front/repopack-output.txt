================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-08-18T19:57:15.269Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
model/textToSpeechSlice.ts
model/types.ts
model/utils.ts
ui/ChapterItem.tsx
ui/ChapterList.tsx
ui/ChapterModal.tsx
ui/ChapterSplitInput.tsx
ui/FileUploader.tsx
ui/Reader.tsx
ui/TextToSpeech.tsx

================================================================
Repository Files
================================================================

================
File: model/textToSpeechSlice.ts
================
import { createSlice, PayloadAction } from '@reduxjs/toolkit';

export interface TextToSpeechState {
  text: string;
}


const initialState: TextToSpeechState = {
  text: '',
};

const textToSpeechSlice = createSlice({
  name: 'textToSpeech',
  initialState,
  reducers: {
    setText: (state, action: PayloadAction<string>) => {
      state.text = action.payload;
    },
  },
});

export const { setText } = textToSpeechSlice.actions;
export default textToSpeechSlice.reducer;

================
File: model/types.ts
================
export interface Chapter {
    title: string;
    content?: string;
    parts?: ChapterPart[];
    charCount: number;
    notes?: HighlightAndNote[];
}

export interface ChapterPart {
    title: string;
    content: string;
    charCount: number;
}
// dont use
export interface Note {
    type: 'pen' | 'speech';
    text: string;
    comment?: string;
}

export interface HighlightAndNote {
  Id: string;                        // –£–Ω–∏–∫–∞–ª—å–Ω—ã–π –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –∑–∞–º–µ—Ç–∫–∏
  Type?: number;                      // –¢–∏–ø –∑–∞–º–µ—Ç–∫–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –≤—ã–¥–µ–ª–µ–Ω–∏–µ –∏–ª–∏ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π)
  ContentNum?: number;                // –ù–æ–º–µ—Ä —Å–æ–¥–µ—Ä–∂–∞–Ω–∏—è –∏–ª–∏ —Ä–∞–∑–¥–µ–ª–∞, –≤ –∫–æ—Ç–æ—Ä–æ–º —Å–¥–µ–ª–∞–Ω–∞ –∑–∞–º–µ—Ç–∫–∞
  ColorId: string;                   // –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä —Ü–≤–µ—Ç–∞ –≤—ã–¥–µ–ª–µ–Ω–∏—è (–º–æ–∂–µ—Ç —É–∫–∞–∑—ã–≤–∞—Ç—å –Ω–∞ –≤–∞–∂–Ω–æ—Å—Ç—å)
  NoteText?: string | null;           // –¢–µ–∫—Å—Ç –∑–∞–º–µ—Ç–∫–∏, –µ—Å–ª–∏ –µ—Å—Ç—å (null, –µ—Å–ª–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç)
  SelectionSnippet: string;          // –§—Ä–∞–≥–º–µ–Ω—Ç –≤—ã–¥–µ–ª–µ–Ω–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞
  SelectionPosition?: number;         // –ü–æ–∑–∏—Ü–∏—è –≤—ã–¥–µ–ª–µ–Ω–∏—è –≤ —Ç–µ–∫—Å—Ç–µ (–º–æ–∂–µ—Ç –±—ã—Ç—å –ø—Ä–æ—Ü–µ–Ω—Ç–æ–º –∏–ª–∏ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–º –ø–æ–ª–æ–∂–µ–Ω–∏–µ–º)
  SelectionTocLocation: string;      // –ú–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ –≤—ã–¥–µ–ª–µ–Ω–∏—è –≤ –æ–≥–ª–∞–≤–ª–µ–Ω–∏–∏ –∫–Ω–∏–≥–∏ (—á–∞—Å—Ç—å, –≥–ª–∞–≤–∞, –ø–æ–¥—Ä–∞–∑–¥–µ–ª)
  SerializedSelection?: string;       // –°–µ—Ä–∏–π–Ω–∞—è —Å—Ç—Ä–æ–∫–∞, –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—â–∞—è —Ç–æ—á–Ω–æ–µ –º–µ—Å—Ç–æ –≤—ã–¥–µ–ª–µ–Ω–∏—è –≤ —Ç–µ–∫—Å—Ç–µ
  TimeStamp: string;                 // –í—Ä–µ–º–µ–Ω–Ω–∞—è –º–µ—Ç–∫–∞, –∫–æ–≥–¥–∞ –±—ã–ª–∞ —Å–¥–µ–ª–∞–Ω–∞ –∑–∞–º–µ—Ç–∫–∞
  IsDeleted?: boolean;                // –§–ª–∞–≥, —É–∫–∞–∑—ã–≤–∞—é—â–∏–π, –±—ã–ª–∞ –ª–∏ –∑–∞–º–µ—Ç–∫–∞ —É–¥–∞–ª–µ–Ω–∞
  IsFavorite?: boolean;               // –§–ª–∞–≥, —É–∫–∞–∑—ã–≤–∞—é—â–∏–π, –±—ã–ª–∞ –ª–∏ –∑–∞–º–µ—Ç–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∞ –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–µ
}



// {
//     "$type": "eBookReader.Utility.HighlightAndNote, Aquile Reader",
//     "Id": "aad0d97559304492b2a837962a6aa818",
//     "Type": 0,
//     "ContentNum": 9,
//     "ColorId": "2",
//     "NoteText": null,
//     "SelectionSnippet": "–ì–ª–∞–≤–Ω–æ–π –∑–∞–¥–∞—á–µ–π ¬´–¥–µ—Ç–µ–∫—Ç–æ—Ä–∞ –æ—à–∏–±–æ–∫¬ª –¥–ª—è —á–µ–ª–æ–≤–µ–∫–∞, –¥–ª—è –µ–≥–æ –≤—ã–∂–∏–≤–∞–Ω–∏—è —è–≤–ª—è–µ—Ç—Å—è —É–º–µ–Ω–∏–µ –æ—Ç–ª–∏—á–∞—Ç—å —Ä–µ–∞–ª—å–Ω–æ—Å—Ç—å –æ—Ç –≤—ã–º—ã—Å–ª–∞, –ø—Ä–∞–≤–¥—É –æ—Ç–æ –ª–∂–∏. –ï—Å–ª–∏ –±—ã —É –Ω–∞—Å –Ω–µ –±—ã–ª–æ —ç—Ç–æ–≥–æ –º–µ—Ö–∞–Ω–∏–∑–º–∞, —Ç–æ –≤—Å–µ —á–µ–ª–æ–≤–µ—á–µ—Å—Ç–≤–æ –ø—Ä–µ–≤—Ä–∞—Ç–∏–ª–æ—Å—å –±—ã –≤ –ª—é–¥–µ–π –∞—É—Ç–∏—á–Ω—ã—Ö –ª–∏–±–æ —Å—Ç—Ä–∞–¥–∞—é—â–∏—Ö —à–∏–∑–æ—Ñ—Ä–µ–Ω–∏–µ–π. –ò–º–µ–Ω–Ω–æ —ç—Ç–∏ –ª—é–¥–∏ —Å—Ç–∞–ª–∫–∏–≤–∞—é—Ç—Å—è —Å –ø—Ä–æ–±–ª–µ–º–æ–π —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è ¬´–¥–µ—Ç–µ–∫—Ç–æ—Ä–∞ –æ—à–∏–±–æ–∫¬ª, —Ç–æ –µ—Å—Ç—å —Å –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ–π —Ä–∞–±–æ—Ç–æ–π —ç—Ç–æ–π —á–∞—Å—Ç–∏ –∫–æ—Ä—ã –≥–æ–ª–æ–≤–Ω–æ–≥–æ –º–æ–∑–≥–∞. –≠—Ç–∏–º —Ñ–∞–∫—Ç–æ–º –∏ –æ–±—ä—è—Å–Ω—è–µ—Ç—Å—è —Å—Ç—Ä–∞–Ω–Ω–æ—Å—Ç—å –∏—Ö –ø–æ–≤–µ–¥–µ–Ω–∏—è —Å —Ç–æ—á–∫–∏ –∑—Ä–µ–Ω–∏—è —Å–æ—Ü–∏—É–º–∞.",
//     "SelectionPosition": 10.42,
//     "SelectionTocLocation": "–ß–∞—Å—Ç—å 1. –ß—Ç–æ —Ç–∞–∫–æ–µ –ª–æ–∂—å ¬ª –ì–ª–∞–≤–∞ 3. –î–µ—Ç–µ–∫—Ç–æ—Ä –æ—à–∏–±–æ–∫, –∏–ª–∏ –ö–∞–∫ –Ω–∞—à –º–æ–∑–≥ —Ä–µ–∞–≥–∏—Ä—É–µ—Ç –Ω–∞ –ª–æ–∂—å",
//     "SerializedSelection": "0/0/26/0/1:0,0/3/26/0/1:74",
//     "TimeStamp": "2024-08-07T23:27:27.3868216+05:00",
//     "IsDeleted": false,
//     "IsFavorite": false
// }

================
File: model/utils.ts
================
import ePub, { Book } from 'epubjs';
import { Chapter, ChapterPart } from './types';
import Spine from 'epubjs/types/spine';

export const processBook = async (book: Book, limit: number): Promise<Chapter[]> => {
    await book.ready;

    const spine = book.spine as Spine & { items: any[] };
    const newChapters: Chapter[] = [];


    
    for (const item of spine.items) {
        const doc = (await book.load(item.href)) as Document;
        console.log(doc);
        
        const chapterText = doc.body?.textContent || '';
        const chapterTitle = extractChapterTitle(doc) || item.label || '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è';

        if (chapterText.length > limit) {
            const parts: ChapterPart[] = [];
            for (let i = 0; i < chapterText.length; i += limit) {
                const partContent = chapterText.slice(i, i + limit);
                parts.push({
                    title: `–ß–∞—Å—Ç—å ${Math.floor(i / limit) + 1}`,
                    content: partContent,
                    charCount: partContent.length,
                });
            }


            newChapters.push({
                title: chapterTitle,
                parts,
                charCount: chapterText.length,
            });
        } else {
            newChapters.push({
                title: chapterTitle,
                content: chapterText,
                charCount: chapterText.length,
            });
        }
    }

    return newChapters;
};

export const saveBookToLocalStorage = (book: Book, chapters: Chapter[]) => {
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ—Å–Ω–æ–≤–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–Ω–∏–≥–µ
    localStorage.setItem(
        'bookMetadata',
        JSON.stringify({
            url: book.url,
            key: book.key,
            packaging: book.packaging,
        })
    );

    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≥–ª–∞–≤—ã
    localStorage.setItem('bookChapters', JSON.stringify(chapters));
};

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –∫–Ω–∏–≥–∏ –∏–∑ localStorage
export const loadBookFromLocalStorage = async (): Promise<{ book: Book | null; chapters: Chapter[] }> => {
    const bookMetadataString = localStorage.getItem('bookMetadata');
    const chaptersString = localStorage.getItem('bookChapters');

    if (!bookMetadataString || !chaptersString) {
        return { book: null, chapters: [] };
    }

    const bookMetadata = JSON.parse(bookMetadataString);
    const chapters = JSON.parse(chaptersString) as Chapter[];

    // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä Book —Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–º–∏ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º–∏
    const book = ePub(bookMetadata.url);
    book.key = bookMetadata.key;
    book.packaging = bookMetadata.packaging;

    console.log('Book loaded from localStorage');
    return { book, chapters };
};

export const extractChapterTitle = (doc: Document): string => {
    const headingElements = doc.querySelectorAll('h1, h2, h3, h4, h5, h6');
    if (headingElements.length > 0) {
        return headingElements[0].textContent?.trim() || '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è';
    }

    const walker = document.createTreeWalker(doc.body, NodeFilter.SHOW_TEXT);
    let node: Node | null;
    while ((node = walker.nextNode())) {
        const text = node.textContent?.trim();
        if (text) {
            return text;
            // return text.substring(0, 50) + (text.length > 50 ? '...' : '');
        }
    }

    return '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è';
};

export const formatCharCount = (count: number): string => {
    return count.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ' ');
};

================
File: ui/ChapterItem.tsx
================
import React, { useState, useRef } from 'react';
import { Button } from '@/shared/ui/components/ui/button';
import { Popover, PopoverContent, PopoverTrigger } from '@/shared/ui/components/ui/popover';
import { ChevronDown, ChevronRight, Copy, Check } from 'lucide-react';
import { Chapter, HighlightAndNote } from '../model/types';
import { formatCharCount } from '../model/utils';
import ChapterModal from './ChapterModal';

interface ChapterItemProps {
    chapter: Chapter;
    index: number;
    expanded: boolean;
    copiedState: boolean;
    onToggle: () => void;
    onCopy: (text: string) => void;
    isTopLevel?: boolean;
}

export const ChapterItem: React.FC<ChapterItemProps> = ({ chapter, expanded, copiedState, onToggle, onCopy, isTopLevel = true }) => {
    const [popupOpen, setPopupOpen] = useState(false);
    const [popupCopied, setPopupCopied] = useState(false);
    const timeoutRef = useRef<NodeJS.Timeout | null>(null);

    const truncateTitle = (title: string, maxLength: number) => {
        return title.length > maxLength ? title.substring(0, maxLength) + '...' : title;
    };

    const formatNotes = (notes: HighlightAndNote[]) => {
        return notes
            .map(
                (note) =>
                    `–í—ã–¥–µ–ª–µ–Ω–∏–µ: ${note.SelectionSnippet}\n` +
                    `–¶–≤–µ—Ç: ${note.ColorId}\n` +
                    (note.NoteText ? `–ö–æ–º–µ–Ω—Ç–∞—Ä–∏–π: ${note.NoteText}\n` : '') +
                    `–†–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏–µ –≤ –æ–≥–ª–∞–≤–ª–µ–Ω–∏–∏: ${note.SelectionTocLocation}\n`
            )
            .join('\n\n');
    };

    const copyContent = () => {
        const chapterContent = chapter.content || chapter.parts?.map((p) => p.content).join('\n\n') || '';
        const notesContent = chapter.notes ? `\n\n–ù–∏–∂–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω—ã –∑–∞–º–µ—Ç–∫–∏ –ø–æ –¥–∞–Ω–Ω–æ–π –≥–ª–∞–≤–µ:\n\n${formatNotes(chapter.notes)}` : '';
        onCopy(chapterContent + notesContent);
    };

    const copyPopupContent = () => {
        const content = chapter.content || chapter.parts?.map((p) => p.content).join('\n\n') || '';
        navigator.clipboard.writeText(content).then(() => {
            setPopupCopied(true);
            setTimeout(() => setPopupCopied(false), 2000);
        });
    };

    const handleMouseEnter = () => {
        if (timeoutRef.current) {
            clearTimeout(timeoutRef.current);
        }
        setPopupOpen(true);
    };

    const handleMouseLeave = () => {
        timeoutRef.current = setTimeout(() => {
            setPopupOpen(false);
        }, 300); // –ó–∞–¥–µ—Ä–∂–∫–∞ –≤ 300 –º—Å –ø–µ—Ä–µ–¥ –∑–∞–∫—Ä—ã—Ç–∏–µ–º
    };

    return (
        <div className={`border rounded mb-1 ${!isTopLevel ? 'p-0' : 'p-[5px]'}`}>
            <div
                className={`flex items-center justify-between group cursor-pointer ${isTopLevel && !chapter.parts && 'ml-[30px]'} ${
                    !isTopLevel && 'ml-4'
                }`}
                onClick={onToggle}
            >
                <Popover open={popupOpen} onOpenChange={setPopupOpen}>
                    <PopoverTrigger asChild>
                        <span className="font-semibold flex items-center relative" onMouseEnter={handleMouseEnter} onMouseLeave={handleMouseLeave}>
                            {chapter.parts && (expanded ? <ChevronDown className="mr-2" /> : <ChevronRight className="mr-2" />)}

                            {truncateTitle(chapter.title, 50)}
                        </span>
                    </PopoverTrigger>
                    {chapter.title.length > 50 && (
                        <PopoverContent
                            className="w-96 max-h-60 overflow-y-auto"
                            onMouseEnter={handleMouseEnter}
                            onMouseLeave={handleMouseLeave}
                            align="start"
                        >
                            <p className="text-sm mb-2">{chapter.title}</p>
                            <Button
                                variant="outline"
                                size="sm"
                                onClick={(e) => {
                                    e.stopPropagation();
                                    copyPopupContent();
                                }}
                            >
                                {popupCopied ? <Check className="mr-2 h-4 w-4" /> : <Copy className="mr-2 h-4 w-4" />}
                                {popupCopied ? '–°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ' : '–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å'}
                            </Button>
                        </PopoverContent>
                    )}
                </Popover>

                <div className="flex items-center space-x-2">
                    <span className="text-sm text-gray-500">({formatCharCount(chapter.charCount)} —Å–∏–º–≤–æ–ª–æ–≤)</span>
                    {chapter.notes && <span className="text-sm text-blue-500">({chapter.notes.length} –∑–∞–º–µ—Ç–æ–∫)</span>}
                    <ChapterModal
                        title={chapter.title}
                        content={chapter.content || chapter.parts?.map((p) => p.content).join('\n\n') || ''}
                        notes={chapter.notes}
                    />
                    <Button
                        variant="outline"
                        size="sm"
                        onClick={(e) => {
                            e.stopPropagation();
                            copyContent();
                        }}
                    >
                        {copiedState ? <Check className="mr-2 h-4 w-4" /> : <Copy className="mr-2 h-4 w-4" />}
                    </Button>
                </div>
            </div>
            {expanded && chapter.parts && (
                <div className="mt-2 pl-6">
                    {chapter.parts.map((part, partIndex) => (
                        <ChapterItem
                            key={partIndex}
                            chapter={part}
                            index={partIndex}
                            expanded={false}
                            copiedState={copiedState}
                            onToggle={() => {}}
                            onCopy={onCopy}
                            isTopLevel={false}
                        />
                    ))}
                </div>
            )}
        </div>
    );
};

================
File: ui/ChapterList.tsx
================
import React, { useState, useCallback } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/shared/ui/components/ui/card';
import { ChapterItem } from './ChapterItem';
import { Chapter } from '../model/types';
import copy from 'clipboard-copy';

interface ChapterListProps {
    chapters: Chapter[];
}

export const ChapterList: React.FC<ChapterListProps> = ({ chapters }) => {
    const [expandedChapters, setExpandedChapters] = useState<Record<number, boolean>>({});
    const [copiedStates, setCopiedStates] = useState<Record<string, boolean>>({});

    const toggleChapter = useCallback((index: number) => {
        setExpandedChapters((prev) => ({ ...prev, [index]: !prev[index] }));
    }, []);

    // –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ + –∑–∞–¥–µ–∂–∫–∞ –Ω–∞ –æ—Ñ—Ä–ª–µ–¥–µ–Ω–Ω–æ–π –≥–ª–∞–≤–µ –ø—Ä–∏ –∫–æ–ø–∏—Ä–æ–∞–≤–Ω–µ–∏
    const copyToClipboard = useCallback((text: string, id: string) => {
        copy(text)
            .then(() => {
                setCopiedStates((prev) => ({ ...prev, [id]: true }));
                setTimeout(() => {
                    setCopiedStates((prev) => ({ ...prev, [id]: false }));
                }, 2000);
            })
            .catch((err: Error) => {
                console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–∏:', err);
            });
    }, []);

    return (
        <Card>
            <CardHeader>
                <CardTitle className="text-xl font-semibold">–°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ</CardTitle>
            </CardHeader>
            <CardContent>
                <div className="space-y-2">
                    {chapters.map((chapter, index) => (
                        <ChapterItem
                            key={index}
                            chapter={chapter}
                            index={index}
                            expanded={expandedChapters[index]}
                            copiedState={copiedStates[`chapter-${index}`]}
                            onToggle={() => toggleChapter(index)}
                            onCopy={(text) => copyToClipboard(text, `chapter-${index}`)}
                        />
                    ))}
                </div>
            </CardContent>
        </Card>
    );
};

================
File: ui/ChapterModal.tsx
================
import React, { useState, useRef, useCallback } from 'react';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from '@/shared/ui/components/ui/dialog';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/shared/ui/components/ui/card';
import { Badge } from '@/shared/ui/components/ui/badge';
import { Button } from '@/shared/ui/components/ui/button';
import { Switch } from '@/shared/ui/components/ui/switch';
import { Popover, PopoverContent, PopoverTrigger } from '@/shared/ui/components/ui/popover';
import { Input } from '@/shared/ui/components/ui/input';
import { HighlightAndNote } from '../model/types';
import { Clipboard, Search, Globe, MessageSquare, Speech } from 'lucide-react';
import { v4 as uuidv4 } from 'uuid';
import { setText } from '../model/textToSpeechSlice';
import { useAppDispatch } from '@/app/providers/config/store';

interface ChapterModalProps {
    title: string;
    content: string;
    notes?: HighlightAndNote[];
}

const ChapterModal: React.FC<ChapterModalProps> = ({ title, content, notes: initialNotes = [] }) => {
    const [showNotes, setShowNotes] = useState(false);
    const [notes, setNotes] = useState(initialNotes);
    const [selectedText, setSelectedText] = useState('');
    const [isPopoverOpen, setIsPopoverOpen] = useState(false);
    const [popoverPosition, setPopoverPosition] = useState({ top: 0, left: 0 });
    const [commentText, setCommentText] = useState('');
    const [isCommentMode, setIsCommentMode] = useState(false);
    const contentRef = useRef<HTMLDivElement>(null);
    const dispatch = useAppDispatch();

    const colorMap: Record<string, string> = {
        '1': 'bg-note-yellow',
        '2': 'bg-note-green',
        '3': 'bg-note-orange',
        '4': 'bg-note-pink',
        '5': 'bg-note-gray',
        '6': 'bg-note-blue',
    };

    const handleTextSelection = useCallback((e: React.MouseEvent) => {
        e.preventDefault();
        const selection = window.getSelection();
        if (selection && selection.toString().trim().length > 0) {
            const range = selection.getRangeAt(0);
            const rect = range.getBoundingClientRect();
            const contentRect = contentRef.current?.getBoundingClientRect();

            if (contentRect) {
                setPopoverPosition({
                    top: rect.top - contentRect.top - 40,
                    left: rect.left - contentRect.left + rect.width / 2,
                });
            }

            setSelectedText(selection.toString().trim());
            setIsPopoverOpen(true);
            setIsCommentMode(false);
        } else {
            setIsPopoverOpen(false);
        }
    }, []);

    const handleContextMenu = useCallback(
        (e: React.MouseEvent) => {
            e.preventDefault();
            handleTextSelection(e);
        },
        [handleTextSelection]
    );

    const clearSelection = () => {
        if (window.getSelection) {
            window.getSelection()?.removeAllRanges();
        }
    };

    const handleColorSelect = (colorId: string) => {
        const newNote: HighlightAndNote = {
            Id: uuidv4(),
            SelectionSnippet: selectedText,
            ColorId: colorId,
            NoteText: commentText,
            Type: 0,
            TimeStamp: new Date().toISOString(),
            SelectionTocLocation: title,
            IsDeleted: false,
        };

        console.log(newNote);

        setNotes([...notes, newNote]);
        setIsPopoverOpen(false);
        clearSelection();
        setSelectedText('');
        setCommentText('');
    };

    const handleCopy = () => {
        navigator.clipboard.writeText(selectedText);
        setIsPopoverOpen(false);
        clearSelection();
    };

    const handleSearch = () => {
        window.open(`https://www.google.com/search?q=${encodeURIComponent(selectedText)}`, '_blank');
        setIsPopoverOpen(false);
        clearSelection();
    };

    const handleTranslate = () => {
        window.open(`https://translate.yandex.com/?text=${encodeURIComponent(selectedText)}`, '_blank');
        setIsPopoverOpen(false);
        clearSelection();
    };

    const handleSpeech = () => {
        dispatch(setText(selectedText));
        setIsPopoverOpen(false);
        clearSelection();
    };

    const handleAddComment = () => {
        setIsCommentMode(true);
    };

    const renderHighlightedContent = () => {
        let highlightedContent = content;
        notes.forEach((note) => {
            const regex = new RegExp(`(${note.SelectionSnippet})`, 'gi');
            highlightedContent = highlightedContent.replace(
                regex,
                `<span class="${colorMap[note.ColorId]} cursor-pointer" data-note-id="${note.Id}">$1</span>`
            );
        });
        return <p dangerouslySetInnerHTML={{ __html: highlightedContent }} className="text-justify text-[16px]" />;
    };

    return (
        <Dialog>
            <DialogTrigger asChild>
                <Button variant="outline" size="sm">
                    –û—Ç–∫—Ä—ã—Ç—å
                </Button>
            </DialogTrigger>
            <DialogContent className="max-w-4xl max-h-[80vh] overflow-y-auto">
                <DialogHeader>
                    <DialogTitle className="flex justify-between items-center">
                        {title}
                        <div className="flex items-center space-x-2">
                            <span>–ì–ª–∞–≤–∞</span>
                            <Switch checked={showNotes} onCheckedChange={setShowNotes} />
                            <span>–ó–∞–º–µ—Ç–∫–∏</span>
                        </div>
                    </DialogTitle>
                </DialogHeader>
                <div className="mt-4 whitespace-pre-wrap relative" onMouseUp={handleTextSelection} onContextMenu={handleContextMenu} ref={contentRef}>
                    {showNotes ? (
                        notes.length ? (
                            notes.map((note, index) => (
                                <Card key={index} className="mb-4">
                                    <CardHeader>
                                        <Badge variant="outline" className={`mr-2 ${colorMap[note.ColorId]}`}>
                                            {note.Type === 0 ? '‚úèÔ∏è' : 'üí¨'}
                                        </Badge>
                                        <CardTitle className="text-lg">{note.SelectionSnippet}</CardTitle>
                                    </CardHeader>
                                    <CardContent>
                                        {note.NoteText && (
                                            <CardDescription className="text-sm text-gray-600 mt-1">–ó–∞–º–µ—Ç–∫–∞: {note.NoteText}</CardDescription>
                                        )}
                                        <CardDescription className="text-sm text-gray-600 mt-1">
                                            –í—Ä–µ–º—è: {new Date(note.TimeStamp).toLocaleString()}
                                        </CardDescription>
                                        <CardDescription className="text-sm text-gray-600">–ü–æ–ª–æ–∂–µ–Ω–∏–µ: {note.SelectionPosition}</CardDescription>
                                    </CardContent>
                                </Card>
                            ))
                        ) : (
                            <CardDescription>–ù–µ—Ç –∑–∞–º–µ—Ç–æ–∫ –¥–ª—è —ç—Ç–æ–π –≥–ª–∞–≤—ã</CardDescription>
                        )
                    ) : (
                        renderHighlightedContent()
                    )}
                    <Popover open={isPopoverOpen} onOpenChange={setIsPopoverOpen}>
                        <PopoverTrigger asChild>
                            <div style={{ position: 'absolute', top: popoverPosition.top, left: popoverPosition.left }} />
                        </PopoverTrigger>
                        <PopoverContent className="w-auto p-2" style={{ transform: 'translateX(-50%)' }}>
                            {isCommentMode ? (
                                <div className="flex flex-col space-y-2">
                                    <Input placeholder="–í–≤–µ–¥–∏—Ç–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π" value={commentText} onChange={(e) => setCommentText(e.target.value)} />
                                    <div className="flex justify-between">
                                        <Button variant="outline" size="sm" onClick={() => setIsCommentMode(false)}>
                                            –û—Ç–º–µ–Ω–∞
                                        </Button>
                                        <Button size="sm" onClick={() => handleColorSelect('1')}>
                                            –°–æ—Ö—Ä–∞–Ω–∏—Ç—å
                                        </Button>
                                    </div>
                                </div>
                            ) : (
                                <div className="flex space-x-2">
                                    <Button variant="outline" size="icon" onClick={handleCopy}>
                                        <Clipboard className="h-4 w-4" />
                                    </Button>
                                    <Button variant="outline" size="icon" onClick={handleSearch}>
                                        <Search className="h-4 w-4" />
                                    </Button>
                                    <Button variant="outline" size="icon" onClick={handleTranslate}>
                                        <Globe className="h-4 w-4" />
                                    </Button>
                                    <Button variant="outline" size="icon" onClick={handleAddComment}>
                                        <MessageSquare className="h-4 w-4" />
                                    </Button>
                                    <Button variant="outline" size="icon" onClick={handleSpeech}>
                                        <Speech className="h-4 w-4" />
                                    </Button>
                                    {Object.entries(colorMap).map(([colorId, colorClass]) => (
                                        <Button
                                            key={colorId}
                                            className={`${colorClass} h-8 w-8 rounded-none border-0`}
                                            variant="ghost"
                                            onClick={() => handleColorSelect(colorId)}
                                        />
                                    ))}
                                </div>
                            )}
                        </PopoverContent>
                    </Popover>
                </div>
            </DialogContent>
        </Dialog>
    );
};

export default ChapterModal;

================
File: ui/ChapterSplitInput.tsx
================
import React, { useRef, useCallback, useState } from 'react';
import { Input } from '@/shared/ui/components/ui/input';
import { Button } from '@/shared/ui/components/ui/button';

interface ChapterSplitInputProps {
    value: number;
    onChange: (value: number) => void;
    onProcessBook?: () => void;
}

export const ChapterSplitInput: React.FC<ChapterSplitInputProps> = ({ value, onChange }) => {
    const [inputValue, setInputValue] = useState(value.toString());

    // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∏–∑–º–µ–Ω–µ–Ω–∏—è –∑–Ω–∞—á–µ–Ω–∏—è –≤ –ø–æ–ª–µ –≤–≤–æ–¥–∞
    const handleInputChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
        setInputValue(e.target.value);
    }, []);

    // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏—è (–ø—Ä–∏ –ø–æ—Ç–µ—Ä–µ —Ñ–æ–∫—É—Å–∞ –∏–ª–∏ –Ω–∞–∂–∞—Ç–∏–∏ Enter)
    const handleConfirmChange = useCallback(() => {
        const newValue = parseInt(inputValue, 10);
        if (!isNaN(newValue) && newValue > 0) {
            onChange(newValue);
        } else {
            // –ï—Å–ª–∏ –≤–≤–µ–¥–µ–Ω–æ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–µ–µ
            setInputValue(value.toString());
        }
    }, [inputValue, onChange, value]);

    // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–∞–∂–∞—Ç–∏—è –∫–ª–∞–≤–∏—à–∏ Enter
    const handleKeyDown = useCallback(
        (e: React.KeyboardEvent<HTMLInputElement>) => {
            if (e.key === 'Enter') {
                handleConfirmChange();
            }
        },
        [handleConfirmChange]
    );

    return (
        <div className="my-4 flex items-center">
            <label htmlFor="chapterSplitLimit" className="mr-2 text-sm font-medium text-gray-700">
                –õ–∏–º–∏—Ç —Å–∏–º–≤–æ–ª–æ–≤ –¥–ª—è —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è –≥–ª–∞–≤—ã:
            </label>
            <Input
                type="text"
                id="chapterSplitLimit"
                value={inputValue}
                onChange={handleInputChange}
                onBlur={handleConfirmChange}
                onKeyDown={handleKeyDown}
                className="w-32 mr-2"
            />
        </div>
    );
};

================
File: ui/FileUploader.tsx
================
import React from 'react';
import { useDropzone, DropzoneOptions } from 'react-dropzone';
import { Card, CardContent, CardHeader, CardTitle } from '@/shared/ui/components/ui/card';
import { Upload, AlertCircle, FileText } from 'lucide-react';
import { cn } from '@/shared/lib/utils';

interface FileUploaderProps {
    onFileSelect: (file: File) => void;
    loading?: boolean;
    error?: string;
    title: string;
    acceptedFileTypes: Record<string, string[]>;
    maxFiles?: number;
    maxSize?: number;
    icon?: React.ReactNode;
    dragActiveText?: string;
    dragInactiveText?: string;
    loadingText?: string;
    className?: string;
}

export const FileUploader: React.FC<FileUploaderProps> = ({
    onFileSelect,
    loading,
    error,
    title,
    acceptedFileTypes,
    maxFiles = 1,
    maxSize,
    icon = <Upload className="mx-auto h-12 w-12 text-gray-400" />,
    dragActiveText = '–û—Ç–ø—É—Å—Ç–∏—Ç–µ —Ñ–∞–π–ª –∑–¥–µ—Å—å...',
    dragInactiveText = '–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ —Ñ–∞–π–ª —Å—é–¥–∞ –∏–ª–∏ –∫–ª–∏–∫–Ω–∏—Ç–µ –¥–ª—è –≤—ã–±–æ—Ä–∞',
    loadingText = '–ó–∞–≥—Ä—É–∑–∫–∞ –∏ –æ–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–∞–π–ª–∞...',
    className,
}) => {
    const [selectedFile, setSelectedFile] = React.useState<File | null>(null);

    const dropzoneOptions: DropzoneOptions = {
        onDrop: (acceptedFiles) => {
            const file = acceptedFiles[0];
            if (file) {
                setSelectedFile(file);
                onFileSelect(file);
            }
        },
        accept: acceptedFileTypes,
        multiple: maxFiles > 1,
        maxFiles,
        maxSize,
    };

    const { getRootProps, getInputProps, isDragActive } = useDropzone(dropzoneOptions);

    // Extract accepted file extensions
    const acceptedExtensions = Object.values(acceptedFileTypes).flat().join(', ');


    return (
        <Card className={cn('mb-4 relative', className)}>
            <CardHeader>
                <div className="flex justify-between items-center">
                    <CardTitle className="text-2xl font-bold">{title}</CardTitle>
                    <span className="text-sm ">Accepted: {acceptedExtensions}</span>
                </div>
            </CardHeader>
            <CardContent>
                <div
                    {...getRootProps()}
                    className={` border-2 border-dashed rounded-lg p-6 text-center transition-colors duration-300 ease-in-out cursor-pointer ${
                        isDragActive
                            ? 'border-blue-500 bg-blue-50'
                            : selectedFile
                            ? 'border-green-500 bg-green-50'
                            : 'border-gray-300 hover:border-gray-400'
                    }`}
                >
                    <input {...getInputProps()} />
                    {selectedFile ? (
                        <div className="flex items-center justify-center w-[400px]">
                            <FileText className="h-8 w-8 text-green-600" />
                            <p className="ml-2 text-green-600">{selectedFile.name}</p>
                        </div>
                    ) : (
                        <>
                            {icon}
                            <p className="mt-2 text-sm text-gray-600 w-[400px] text-center">{isDragActive ? dragActiveText : dragInactiveText}</p>
                        </>
                    )}
                </div>
                {loading && <p className="text-blue-500 mt-6 absolute right-1/4 -bottom-8">{loadingText}</p>}
                {error && error !== 'No file selected' && (
                    <div className="flex items-center text-red-500 mt-4">
                        <AlertCircle className="mr-2" />
                        <span>{error}</span>
                    </div>
                )}
            </CardContent>
        </Card>
    );
};

================
File: ui/Reader.tsx
================
import React, { useState, useCallback, useEffect } from 'react';
import ePub, { Book } from 'epubjs';
import { ChapterList } from './ChapterList';
import { FileUploader } from './FileUploader';
import { ChapterSplitInput } from './ChapterSplitInput';
import { processBook } from '../model/utils';
import { Chapter, HighlightAndNote } from '../model/types';
import { saveBookToLocalStorage, loadBookFromLocalStorage } from '../model/utils';
import { Select, SelectContent, SelectGroup, SelectItem, SelectLabel, SelectTrigger, SelectValue } from '@/shared/ui/components/ui/select';
import { Input } from '@/shared/ui/components/ui/input';
import TextToSpeech from './TextToSpeech';
import { FileJson2 } from 'lucide-react';

const Reader: React.FC = () => {
    const [book, setBook] = useState<Book | null>(null);
    const [chapters, setChapters] = useState<Chapter[]>([]);
    const [loading, setLoading] = useState<boolean>(false);
    const [error, setError] = useState<string>('');
    const [chapterSplitLimit, setChapterSplitLimit] = useState<number>(() => {
        const saved = localStorage.getItem('chapterSplitLimit');
        return saved ? parseInt(saved, 10) : 30000;
    });
    const [selectedReader, setSelectedReader] = useState('aquile');

    useEffect(() => {
        const loadSavedBook = async () => {
            const { book: savedBook, chapters: savedChapters } = await loadBookFromLocalStorage();
            if (savedBook && savedChapters.length > 0) {
                setBook(savedBook);
                setChapters(savedChapters);
            }
        };

        loadSavedBook();
    }, []);

    useEffect(() => {
        if (book && chapters.length > 0) {
            saveBookToLocalStorage(book, chapters);
        }
    }, [book, chapters]);

    const handleFile = useCallback(
        async (file: File) => {
            setLoading(true);
            setError('');
            try {
                const reader = new FileReader();
                reader.onload = async (e: ProgressEvent<FileReader>) => {
                    if (e.target && e.target.result) {
                        const bookData = e.target.result;
                        const newBook = ePub(bookData as ArrayBuffer);
                        setBook(newBook);
                        const processedChapters = await processBook(newBook, chapterSplitLimit);

                        
                        setChapters(processedChapters);
                        saveBookToLocalStorage(newBook, processedChapters);
                    }
                };
                reader.readAsArrayBuffer(file);
            } catch (err) {
                setError(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Ñ–∞–π–ª–∞: ${(err as Error).message}`);
            } finally {
                setLoading(false);
            }
        },
        [chapterSplitLimit]
    );


    // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è –ª–∏–º–∏—Ç–∞ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è –≥–ª–∞–≤
    const handleChapterSplitLimitChange = useCallback(
        async (newLimit: number) => {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –Ω–æ–≤—ã–π –ª–∏–º–∏—Ç –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è –æ—Ç —Ç–µ–∫—É—â–µ–≥–æ
            if (newLimit !== chapterSplitLimit) {
                setChapterSplitLimit(newLimit);
                localStorage.setItem('chapterSplitLimit', newLimit.toString());

                // –ï—Å–ª–∏ –∫–Ω–∏–≥–∞ –∑–∞–≥—Ä—É–∂–µ–Ω–∞, –ø–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º –≥–ª–∞–≤—ã
                if (book) {
                    setLoading(true);
                    try {
                        const processedChapters = await processBook(book, newLimit);
                        setChapters(processedChapters);
                        saveBookToLocalStorage(book, processedChapters);
                    } catch (err) {
                        setError(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∫–Ω–∏–≥–∏: ${(err as Error).message}`);
                    } finally {
                        setLoading(false);
                    }
                }
            }
        },
        [book, chapterSplitLimit]
    );

    const normalizeChapterTitle = (title: string): string => {
        const parts = title.split('¬ª');
        if (parts.length > 1) {
            return parts[parts.length - 1].trim();
        }
        return title.trim();
    };

    const handleNotesFile = useCallback(async (file: File) => {
        try {
            const text = await file.text();
            const notesData = JSON.parse(text);

            // –ü–∞—Ä—Å–∏–º –∑–∞–º–µ—Ç–∫–∏ –∏ –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤—ã–≤–∞–µ–º —Ç–µ, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ —É–¥–∞–ª–µ–Ω—ã
            const notes: HighlightAndNote[] = notesData.$values.filter((note: HighlightAndNote) => !note.IsDeleted);

            const notesMap: Record<string, HighlightAndNote[]> = {};
            notes.forEach((note) => {
                const chapterTitle = normalizeChapterTitle(note.SelectionTocLocation);
                if (!notesMap[chapterTitle]) {
                    notesMap[chapterTitle] = [];
                }
                notesMap[chapterTitle].push(note);
            });

            console.log(notesMap);

            // –û–±–Ω–æ–≤–ª—è–µ–º –≥–ª–∞–≤—ã —Å –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ –∑–∞–º–µ—Ç–∫–∞–º–∏
            setChapters((prevChapters) =>
                prevChapters.map((chapter) => ({
                    ...chapter,
                    notes: notesMap[normalizeChapterTitle(chapter.title)] || [],
                }))
            );
        } catch (error) {
            console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Ñ–∞–π–ª–∞:', error);
        }

        console.log('Updated chapters:', chapters);
    }, []);


    return (
        <div className="container mx-auto p-4">
            <div className="flex justify-between items-center gap-5">
                <FileUploader
                    onFileSelect={handleFile}
                    loading={loading}
                    error={error}
                    title="EPUB Reader"
                    acceptedFileTypes={{ 'application/epub+zip': ['.epub'] }}
                    loadingText="–ó–∞–≥—Ä—É–∑–∫–∞ –∏ –æ–±—Ä–∞–±–æ—Ç–∫–∞ EPUB —Ñ–∞–π–ª–∞..."
                    className="w-full h-[230px]"
                />
                <FileUploader
                    onFileSelect={handleNotesFile}
                    loading={loading}
                    error={error}
                    title="Highlighting notes"
                    acceptedFileTypes={{ 'application/json': ['.json'] }}
                    loadingText="–ó–∞–≥—Ä—É–∑–∫–∞ –∏ –æ–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–∞–π–ª–∞ –∑–∞–º–µ—Ç–æ–∫..."
                    icon={<FileJson2 className="mx-auto h-12 w-12 text-gray-400" />}
                    className="w-full h-[230px]"
                />
            </div>

            <TextToSpeech />
            <ChapterSplitInput value={chapterSplitLimit} onChange={handleChapterSplitLimitChange} />
            <h3 className="mb-5">Exporting Reader</h3>
            <Select value={selectedReader} onValueChange={setSelectedReader}>
                <SelectTrigger className="w-[180px]">
                    <SelectValue />
                </SelectTrigger>
                <SelectContent>
                    <SelectGroup>
                        <SelectItem value="aquile">Aquile Reader</SelectItem>
                        <SelectItem value="pocketbook">PocketBook</SelectItem>
                    </SelectGroup>
                </SelectContent>
            </Select>

            <ChapterList chapters={chapters} />
        </div>
    );
};

export default Reader;

================
File: ui/TextToSpeech.tsx
================
import { useState, useEffect, useRef } from 'react';
import { Button } from '@/shared/ui/components/ui/button';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/shared/ui/components/ui/select';
import { Slider } from '@/shared/ui/components/ui/slider';
import { useDispatch } from 'react-redux';
import { useAppSelector } from '@/app/providers/config/store';

const TextToSpeech = () => {
    const dispatch = useDispatch();
    const text = useAppSelector((state) => state.textToSpeech.text);
    const [voices, setVoices] = useState<SpeechSynthesisVoice[]>([]);
    const [selectedVoice, setSelectedVoice] = useState<SpeechSynthesisVoice | null>(null);
    const [rate, setRate] = useState(6);
    const [isSpeaking, setIsSpeaking] = useState(false);
    const [isPaused, setIsPaused] = useState(false);
    const [currentSentence, setCurrentSentence] = useState(0);
    const synthRef = useRef<SpeechSynthesis>(window.speechSynthesis);
    const utteranceRef = useRef<SpeechSynthesisUtterance | null>(null);

    // set voices by default
    useEffect(() => {
        const updateVoices = () => {
            const availableVoices = synthRef.current.getVoices();
            setVoices(availableVoices);
            const pavelVoice = availableVoices.find((voice) => voice.name === 'Microsoft Pavel - Russian (Russia)');
            if (pavelVoice) {
                setSelectedVoice(pavelVoice);
            }
        };
        updateVoices();
        if (speechSynthesis.onvoiceschanged !== undefined) {
            speechSynthesis.onvoiceschanged = updateVoices;
        }
    }, []);

    useEffect(() => {
        if (text) {
            handleSpeak();
        }
    }, [text]);

    const sentences = text.match(/[^.!?]+[.!?]+/g) || [text];

    const handleSpeak = () => {
        if (synthRef.current.speaking) {
            synthRef.current.cancel();
        }
        if (text !== '') {
            utteranceRef.current = new SpeechSynthesisUtterance(text);
            if (selectedVoice) {
                utteranceRef.current.voice = selectedVoice;
            }
            utteranceRef.current.rate = rate;
            utteranceRef.current.onstart = () => setIsSpeaking(true);
            utteranceRef.current.onend = () => {
                setIsSpeaking(false);
                setCurrentSentence(0);
            };
            utteranceRef.current.onboundary = (event: SpeechSynthesisEvent) => {
                const sentenceIndex = sentences.findIndex((sentence, index) => {
                    const start = sentences.slice(0, index).join('').length;
                    const end = start + sentence.length;
                    return event.charIndex >= start && event.charIndex < end;
                });
                if (sentenceIndex !== -1) {
                    setCurrentSentence(sentenceIndex);
                }
            };
            utteranceRef.current.onerror = (event: SpeechSynthesisErrorEvent) => {
                console.error('SpeechSynthesisUtterance error', event);
                setIsSpeaking(false);
                setCurrentSentence(0);
            };
            synthRef.current.speak(utteranceRef.current);
        }
    };

    const handlePauseResume = () => {
        if (isPaused) {
            synthRef.current.resume();
            setIsPaused(false);
        } else {
            synthRef.current.pause();
            setIsPaused(true);
        }
    };

    const handleStop = () => {
        synthRef.current.cancel();
        setIsSpeaking(false);
        setIsPaused(false);
        setCurrentSentence(0);
    };

    const highlightText = () => {
        return sentences.map((sentence, index) => (
            <span key={index} className={index === currentSentence ? 'bg-cyan-900' : ''}>
                {sentence}
            </span>
        ));
    };

    return (
        <div className="w-full ">
            <div className="p-6">
                <p className="mb-4 p-2 border rounded">{isSpeaking ? highlightText() : text}</p>
                <Select
                    value={selectedVoice ? selectedVoice.name : ''}
                    onValueChange={(value) => setSelectedVoice(voices.find((voice) => voice.name === value) || null)}
                >
                    <SelectTrigger className="w-full mb-4">
                        <SelectValue placeholder="–í—ã–±–µ—Ä–∏—Ç–µ –≥–æ–ª–æ—Å" />
                    </SelectTrigger>
                    <SelectContent>
                        {voices.map((voice) => (
                            <SelectItem key={voice.name} value={voice.name}>
                                {voice.name} ({voice.lang})
                            </SelectItem>
                        ))}
                    </SelectContent>
                </Select>
                <div className="mb-4">
                    <label className="block mb-2">–°–∫–æ—Ä–æ—Å—Ç—å —Ä–µ—á–∏: {rate.toFixed(1)}x</label>
                    <Slider min={0.1} max={10} step={0.1} value={[rate]} onValueChange={(values) => setRate(values[0])} className="w-full" />
                </div>
                <div className="flex space-x-2">
                    <Button onClick={handleSpeak} disabled={isSpeaking && !isPaused}>
                        {isSpeaking ? '–ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å' : '–û–∑–≤—É—á–∏—Ç—å'}
                    </Button>
                    <Button variant="secondary" onClick={handlePauseResume} disabled={!isSpeaking}>
                        {isPaused ? '–í–æ–∑–æ–±–Ω–æ–≤–∏—Ç—å' : '–ü–∞—É–∑–∞'}
                    </Button>
                    <Button variant="destructive" onClick={handleStop} disabled={!isSpeaking && !isPaused}>
                        –°—Ç–æ–ø
                    </Button>
                </div>
            </div>
        </div>
    );
};

export default TextToSpeech;
