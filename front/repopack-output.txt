================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-08-18T19:57:15.269Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
model/textToSpeechSlice.ts
model/types.ts
model/utils.ts
ui/ChapterItem.tsx
ui/ChapterList.tsx
ui/ChapterModal.tsx
ui/ChapterSplitInput.tsx
ui/FileUploader.tsx
ui/Reader.tsx
ui/TextToSpeech.tsx

================================================================
Repository Files
================================================================

================
File: model/textToSpeechSlice.ts
================
import { createSlice, PayloadAction } from '@reduxjs/toolkit';

export interface TextToSpeechState {
  text: string;
}


const initialState: TextToSpeechState = {
  text: '',
};

const textToSpeechSlice = createSlice({
  name: 'textToSpeech',
  initialState,
  reducers: {
    setText: (state, action: PayloadAction<string>) => {
      state.text = action.payload;
    },
  },
});

export const { setText } = textToSpeechSlice.actions;
export default textToSpeechSlice.reducer;

================
File: model/types.ts
================
export interface Chapter {
    title: string;
    content?: string;
    parts?: ChapterPart[];
    charCount: number;
    notes?: HighlightAndNote[];
}

export interface ChapterPart {
    title: string;
    content: string;
    charCount: number;
}
// dont use
export interface Note {
    type: 'pen' | 'speech';
    text: string;
    comment?: string;
}

export interface HighlightAndNote {
  Id: string;                        // Уникальный идентификатор заметки
  Type?: number;                      // Тип заметки (например, выделение или комментарий)
  ContentNum?: number;                // Номер содержания или раздела, в котором сделана заметка
  ColorId: string;                   // Идентификатор цвета выделения (может указывать на важность)
  NoteText?: string | null;           // Текст заметки, если есть (null, если отсутствует)
  SelectionSnippet: string;          // Фрагмент выделенного текста
  SelectionPosition?: number;         // Позиция выделения в тексте (может быть процентом или относительным положением)
  SelectionTocLocation: string;      // Местоположение выделения в оглавлении книги (часть, глава, подраздел)
  SerializedSelection?: string;       // Серийная строка, представляющая точное место выделения в тексте
  TimeStamp: string;                 // Временная метка, когда была сделана заметка
  IsDeleted?: boolean;                // Флаг, указывающий, была ли заметка удалена
  IsFavorite?: boolean;               // Флаг, указывающий, была ли заметка добавлена в избранное
}



// {
//     "$type": "eBookReader.Utility.HighlightAndNote, Aquile Reader",
//     "Id": "aad0d97559304492b2a837962a6aa818",
//     "Type": 0,
//     "ContentNum": 9,
//     "ColorId": "2",
//     "NoteText": null,
//     "SelectionSnippet": "Главной задачей «детектора ошибок» для человека, для его выживания является умение отличать реальность от вымысла, правду ото лжи. Если бы у нас не было этого механизма, то все человечество превратилось бы в людей аутичных либо страдающих шизофренией. Именно эти люди сталкиваются с проблемой функционирования «детектора ошибок», то есть с неправильной работой этой части коры головного мозга. Этим фактом и объясняется странность их поведения с точки зрения социума.",
//     "SelectionPosition": 10.42,
//     "SelectionTocLocation": "Часть 1. Что такое ложь » Глава 3. Детектор ошибок, или Как наш мозг реагирует на ложь",
//     "SerializedSelection": "0/0/26/0/1:0,0/3/26/0/1:74",
//     "TimeStamp": "2024-08-07T23:27:27.3868216+05:00",
//     "IsDeleted": false,
//     "IsFavorite": false
// }

================
File: model/utils.ts
================
import ePub, { Book } from 'epubjs';
import { Chapter, ChapterPart } from './types';
import Spine from 'epubjs/types/spine';

export const processBook = async (book: Book, limit: number): Promise<Chapter[]> => {
    await book.ready;

    const spine = book.spine as Spine & { items: any[] };
    const newChapters: Chapter[] = [];


    
    for (const item of spine.items) {
        const doc = (await book.load(item.href)) as Document;
        console.log(doc);
        
        const chapterText = doc.body?.textContent || '';
        const chapterTitle = extractChapterTitle(doc) || item.label || 'Без названия';

        if (chapterText.length > limit) {
            const parts: ChapterPart[] = [];
            for (let i = 0; i < chapterText.length; i += limit) {
                const partContent = chapterText.slice(i, i + limit);
                parts.push({
                    title: `Часть ${Math.floor(i / limit) + 1}`,
                    content: partContent,
                    charCount: partContent.length,
                });
            }


            newChapters.push({
                title: chapterTitle,
                parts,
                charCount: chapterText.length,
            });
        } else {
            newChapters.push({
                title: chapterTitle,
                content: chapterText,
                charCount: chapterText.length,
            });
        }
    }

    return newChapters;
};

export const saveBookToLocalStorage = (book: Book, chapters: Chapter[]) => {
    // Сохраняем основную информацию о книге
    localStorage.setItem(
        'bookMetadata',
        JSON.stringify({
            url: book.url,
            key: book.key,
            packaging: book.packaging,
        })
    );

    // Сохраняем главы
    localStorage.setItem('bookChapters', JSON.stringify(chapters));
};

// Функция для загрузки книги из localStorage
export const loadBookFromLocalStorage = async (): Promise<{ book: Book | null; chapters: Chapter[] }> => {
    const bookMetadataString = localStorage.getItem('bookMetadata');
    const chaptersString = localStorage.getItem('bookChapters');

    if (!bookMetadataString || !chaptersString) {
        return { book: null, chapters: [] };
    }

    const bookMetadata = JSON.parse(bookMetadataString);
    const chapters = JSON.parse(chaptersString) as Chapter[];

    // Создаем новый экземпляр Book с сохраненными метаданными
    const book = ePub(bookMetadata.url);
    book.key = bookMetadata.key;
    book.packaging = bookMetadata.packaging;

    console.log('Book loaded from localStorage');
    return { book, chapters };
};

export const extractChapterTitle = (doc: Document): string => {
    const headingElements = doc.querySelectorAll('h1, h2, h3, h4, h5, h6');
    if (headingElements.length > 0) {
        return headingElements[0].textContent?.trim() || 'Без названия';
    }

    const walker = document.createTreeWalker(doc.body, NodeFilter.SHOW_TEXT);
    let node: Node | null;
    while ((node = walker.nextNode())) {
        const text = node.textContent?.trim();
        if (text) {
            return text;
            // return text.substring(0, 50) + (text.length > 50 ? '...' : '');
        }
    }

    return 'Без названия';
};

export const formatCharCount = (count: number): string => {
    return count.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ' ');
};

================
File: ui/ChapterItem.tsx
================
import React, { useState, useRef } from 'react';
import { Button } from '@/shared/ui/components/ui/button';
import { Popover, PopoverContent, PopoverTrigger } from '@/shared/ui/components/ui/popover';
import { ChevronDown, ChevronRight, Copy, Check } from 'lucide-react';
import { Chapter, HighlightAndNote } from '../model/types';
import { formatCharCount } from '../model/utils';
import ChapterModal from './ChapterModal';

interface ChapterItemProps {
    chapter: Chapter;
    index: number;
    expanded: boolean;
    copiedState: boolean;
    onToggle: () => void;
    onCopy: (text: string) => void;
    isTopLevel?: boolean;
}

export const ChapterItem: React.FC<ChapterItemProps> = ({ chapter, expanded, copiedState, onToggle, onCopy, isTopLevel = true }) => {
    const [popupOpen, setPopupOpen] = useState(false);
    const [popupCopied, setPopupCopied] = useState(false);
    const timeoutRef = useRef<NodeJS.Timeout | null>(null);

    const truncateTitle = (title: string, maxLength: number) => {
        return title.length > maxLength ? title.substring(0, maxLength) + '...' : title;
    };

    const formatNotes = (notes: HighlightAndNote[]) => {
        return notes
            .map(
                (note) =>
                    `Выделение: ${note.SelectionSnippet}\n` +
                    `Цвет: ${note.ColorId}\n` +
                    (note.NoteText ? `Коментарий: ${note.NoteText}\n` : '') +
                    `Расположение в оглавлении: ${note.SelectionTocLocation}\n`
            )
            .join('\n\n');
    };

    const copyContent = () => {
        const chapterContent = chapter.content || chapter.parts?.map((p) => p.content).join('\n\n') || '';
        const notesContent = chapter.notes ? `\n\nНиже представлены заметки по данной главе:\n\n${formatNotes(chapter.notes)}` : '';
        onCopy(chapterContent + notesContent);
    };

    const copyPopupContent = () => {
        const content = chapter.content || chapter.parts?.map((p) => p.content).join('\n\n') || '';
        navigator.clipboard.writeText(content).then(() => {
            setPopupCopied(true);
            setTimeout(() => setPopupCopied(false), 2000);
        });
    };

    const handleMouseEnter = () => {
        if (timeoutRef.current) {
            clearTimeout(timeoutRef.current);
        }
        setPopupOpen(true);
    };

    const handleMouseLeave = () => {
        timeoutRef.current = setTimeout(() => {
            setPopupOpen(false);
        }, 300); // Задержка в 300 мс перед закрытием
    };

    return (
        <div className={`border rounded mb-1 ${!isTopLevel ? 'p-0' : 'p-[5px]'}`}>
            <div
                className={`flex items-center justify-between group cursor-pointer ${isTopLevel && !chapter.parts && 'ml-[30px]'} ${
                    !isTopLevel && 'ml-4'
                }`}
                onClick={onToggle}
            >
                <Popover open={popupOpen} onOpenChange={setPopupOpen}>
                    <PopoverTrigger asChild>
                        <span className="font-semibold flex items-center relative" onMouseEnter={handleMouseEnter} onMouseLeave={handleMouseLeave}>
                            {chapter.parts && (expanded ? <ChevronDown className="mr-2" /> : <ChevronRight className="mr-2" />)}

                            {truncateTitle(chapter.title, 50)}
                        </span>
                    </PopoverTrigger>
                    {chapter.title.length > 50 && (
                        <PopoverContent
                            className="w-96 max-h-60 overflow-y-auto"
                            onMouseEnter={handleMouseEnter}
                            onMouseLeave={handleMouseLeave}
                            align="start"
                        >
                            <p className="text-sm mb-2">{chapter.title}</p>
                            <Button
                                variant="outline"
                                size="sm"
                                onClick={(e) => {
                                    e.stopPropagation();
                                    copyPopupContent();
                                }}
                            >
                                {popupCopied ? <Check className="mr-2 h-4 w-4" /> : <Copy className="mr-2 h-4 w-4" />}
                                {popupCopied ? 'Скопировано' : 'Копировать'}
                            </Button>
                        </PopoverContent>
                    )}
                </Popover>

                <div className="flex items-center space-x-2">
                    <span className="text-sm text-gray-500">({formatCharCount(chapter.charCount)} символов)</span>
                    {chapter.notes && <span className="text-sm text-blue-500">({chapter.notes.length} заметок)</span>}
                    <ChapterModal
                        title={chapter.title}
                        content={chapter.content || chapter.parts?.map((p) => p.content).join('\n\n') || ''}
                        notes={chapter.notes}
                    />
                    <Button
                        variant="outline"
                        size="sm"
                        onClick={(e) => {
                            e.stopPropagation();
                            copyContent();
                        }}
                    >
                        {copiedState ? <Check className="mr-2 h-4 w-4" /> : <Copy className="mr-2 h-4 w-4" />}
                    </Button>
                </div>
            </div>
            {expanded && chapter.parts && (
                <div className="mt-2 pl-6">
                    {chapter.parts.map((part, partIndex) => (
                        <ChapterItem
                            key={partIndex}
                            chapter={part}
                            index={partIndex}
                            expanded={false}
                            copiedState={copiedState}
                            onToggle={() => {}}
                            onCopy={onCopy}
                            isTopLevel={false}
                        />
                    ))}
                </div>
            )}
        </div>
    );
};

================
File: ui/ChapterList.tsx
================
import React, { useState, useCallback } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/shared/ui/components/ui/card';
import { ChapterItem } from './ChapterItem';
import { Chapter } from '../model/types';
import copy from 'clipboard-copy';

interface ChapterListProps {
    chapters: Chapter[];
}

export const ChapterList: React.FC<ChapterListProps> = ({ chapters }) => {
    const [expandedChapters, setExpandedChapters] = useState<Record<number, boolean>>({});
    const [copiedStates, setCopiedStates] = useState<Record<string, boolean>>({});

    const toggleChapter = useCallback((index: number) => {
        setExpandedChapters((prev) => ({ ...prev, [index]: !prev[index] }));
    }, []);

    // копирование + задежка на офрледенной главе при копироавнеи
    const copyToClipboard = useCallback((text: string, id: string) => {
        copy(text)
            .then(() => {
                setCopiedStates((prev) => ({ ...prev, [id]: true }));
                setTimeout(() => {
                    setCopiedStates((prev) => ({ ...prev, [id]: false }));
                }, 2000);
            })
            .catch((err: Error) => {
                console.error('Ошибка при копировании:', err);
            });
    }, []);

    return (
        <Card>
            <CardHeader>
                <CardTitle className="text-xl font-semibold">Содержание</CardTitle>
            </CardHeader>
            <CardContent>
                <div className="space-y-2">
                    {chapters.map((chapter, index) => (
                        <ChapterItem
                            key={index}
                            chapter={chapter}
                            index={index}
                            expanded={expandedChapters[index]}
                            copiedState={copiedStates[`chapter-${index}`]}
                            onToggle={() => toggleChapter(index)}
                            onCopy={(text) => copyToClipboard(text, `chapter-${index}`)}
                        />
                    ))}
                </div>
            </CardContent>
        </Card>
    );
};

================
File: ui/ChapterModal.tsx
================
import React, { useState, useRef, useCallback } from 'react';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from '@/shared/ui/components/ui/dialog';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/shared/ui/components/ui/card';
import { Badge } from '@/shared/ui/components/ui/badge';
import { Button } from '@/shared/ui/components/ui/button';
import { Switch } from '@/shared/ui/components/ui/switch';
import { Popover, PopoverContent, PopoverTrigger } from '@/shared/ui/components/ui/popover';
import { Input } from '@/shared/ui/components/ui/input';
import { HighlightAndNote } from '../model/types';
import { Clipboard, Search, Globe, MessageSquare, Speech } from 'lucide-react';
import { v4 as uuidv4 } from 'uuid';
import { setText } from '../model/textToSpeechSlice';
import { useAppDispatch } from '@/app/providers/config/store';

interface ChapterModalProps {
    title: string;
    content: string;
    notes?: HighlightAndNote[];
}

const ChapterModal: React.FC<ChapterModalProps> = ({ title, content, notes: initialNotes = [] }) => {
    const [showNotes, setShowNotes] = useState(false);
    const [notes, setNotes] = useState(initialNotes);
    const [selectedText, setSelectedText] = useState('');
    const [isPopoverOpen, setIsPopoverOpen] = useState(false);
    const [popoverPosition, setPopoverPosition] = useState({ top: 0, left: 0 });
    const [commentText, setCommentText] = useState('');
    const [isCommentMode, setIsCommentMode] = useState(false);
    const contentRef = useRef<HTMLDivElement>(null);
    const dispatch = useAppDispatch();

    const colorMap: Record<string, string> = {
        '1': 'bg-note-yellow',
        '2': 'bg-note-green',
        '3': 'bg-note-orange',
        '4': 'bg-note-pink',
        '5': 'bg-note-gray',
        '6': 'bg-note-blue',
    };

    const handleTextSelection = useCallback((e: React.MouseEvent) => {
        e.preventDefault();
        const selection = window.getSelection();
        if (selection && selection.toString().trim().length > 0) {
            const range = selection.getRangeAt(0);
            const rect = range.getBoundingClientRect();
            const contentRect = contentRef.current?.getBoundingClientRect();

            if (contentRect) {
                setPopoverPosition({
                    top: rect.top - contentRect.top - 40,
                    left: rect.left - contentRect.left + rect.width / 2,
                });
            }

            setSelectedText(selection.toString().trim());
            setIsPopoverOpen(true);
            setIsCommentMode(false);
        } else {
            setIsPopoverOpen(false);
        }
    }, []);

    const handleContextMenu = useCallback(
        (e: React.MouseEvent) => {
            e.preventDefault();
            handleTextSelection(e);
        },
        [handleTextSelection]
    );

    const clearSelection = () => {
        if (window.getSelection) {
            window.getSelection()?.removeAllRanges();
        }
    };

    const handleColorSelect = (colorId: string) => {
        const newNote: HighlightAndNote = {
            Id: uuidv4(),
            SelectionSnippet: selectedText,
            ColorId: colorId,
            NoteText: commentText,
            Type: 0,
            TimeStamp: new Date().toISOString(),
            SelectionTocLocation: title,
            IsDeleted: false,
        };

        console.log(newNote);

        setNotes([...notes, newNote]);
        setIsPopoverOpen(false);
        clearSelection();
        setSelectedText('');
        setCommentText('');
    };

    const handleCopy = () => {
        navigator.clipboard.writeText(selectedText);
        setIsPopoverOpen(false);
        clearSelection();
    };

    const handleSearch = () => {
        window.open(`https://www.google.com/search?q=${encodeURIComponent(selectedText)}`, '_blank');
        setIsPopoverOpen(false);
        clearSelection();
    };

    const handleTranslate = () => {
        window.open(`https://translate.yandex.com/?text=${encodeURIComponent(selectedText)}`, '_blank');
        setIsPopoverOpen(false);
        clearSelection();
    };

    const handleSpeech = () => {
        dispatch(setText(selectedText));
        setIsPopoverOpen(false);
        clearSelection();
    };

    const handleAddComment = () => {
        setIsCommentMode(true);
    };

    const renderHighlightedContent = () => {
        let highlightedContent = content;
        notes.forEach((note) => {
            const regex = new RegExp(`(${note.SelectionSnippet})`, 'gi');
            highlightedContent = highlightedContent.replace(
                regex,
                `<span class="${colorMap[note.ColorId]} cursor-pointer" data-note-id="${note.Id}">$1</span>`
            );
        });
        return <p dangerouslySetInnerHTML={{ __html: highlightedContent }} className="text-justify text-[16px]" />;
    };

    return (
        <Dialog>
            <DialogTrigger asChild>
                <Button variant="outline" size="sm">
                    Открыть
                </Button>
            </DialogTrigger>
            <DialogContent className="max-w-4xl max-h-[80vh] overflow-y-auto">
                <DialogHeader>
                    <DialogTitle className="flex justify-between items-center">
                        {title}
                        <div className="flex items-center space-x-2">
                            <span>Глава</span>
                            <Switch checked={showNotes} onCheckedChange={setShowNotes} />
                            <span>Заметки</span>
                        </div>
                    </DialogTitle>
                </DialogHeader>
                <div className="mt-4 whitespace-pre-wrap relative" onMouseUp={handleTextSelection} onContextMenu={handleContextMenu} ref={contentRef}>
                    {showNotes ? (
                        notes.length ? (
                            notes.map((note, index) => (
                                <Card key={index} className="mb-4">
                                    <CardHeader>
                                        <Badge variant="outline" className={`mr-2 ${colorMap[note.ColorId]}`}>
                                            {note.Type === 0 ? '✏️' : '💬'}
                                        </Badge>
                                        <CardTitle className="text-lg">{note.SelectionSnippet}</CardTitle>
                                    </CardHeader>
                                    <CardContent>
                                        {note.NoteText && (
                                            <CardDescription className="text-sm text-gray-600 mt-1">Заметка: {note.NoteText}</CardDescription>
                                        )}
                                        <CardDescription className="text-sm text-gray-600 mt-1">
                                            Время: {new Date(note.TimeStamp).toLocaleString()}
                                        </CardDescription>
                                        <CardDescription className="text-sm text-gray-600">Положение: {note.SelectionPosition}</CardDescription>
                                    </CardContent>
                                </Card>
                            ))
                        ) : (
                            <CardDescription>Нет заметок для этой главы</CardDescription>
                        )
                    ) : (
                        renderHighlightedContent()
                    )}
                    <Popover open={isPopoverOpen} onOpenChange={setIsPopoverOpen}>
                        <PopoverTrigger asChild>
                            <div style={{ position: 'absolute', top: popoverPosition.top, left: popoverPosition.left }} />
                        </PopoverTrigger>
                        <PopoverContent className="w-auto p-2" style={{ transform: 'translateX(-50%)' }}>
                            {isCommentMode ? (
                                <div className="flex flex-col space-y-2">
                                    <Input placeholder="Введите комментарий" value={commentText} onChange={(e) => setCommentText(e.target.value)} />
                                    <div className="flex justify-between">
                                        <Button variant="outline" size="sm" onClick={() => setIsCommentMode(false)}>
                                            Отмена
                                        </Button>
                                        <Button size="sm" onClick={() => handleColorSelect('1')}>
                                            Сохранить
                                        </Button>
                                    </div>
                                </div>
                            ) : (
                                <div className="flex space-x-2">
                                    <Button variant="outline" size="icon" onClick={handleCopy}>
                                        <Clipboard className="h-4 w-4" />
                                    </Button>
                                    <Button variant="outline" size="icon" onClick={handleSearch}>
                                        <Search className="h-4 w-4" />
                                    </Button>
                                    <Button variant="outline" size="icon" onClick={handleTranslate}>
                                        <Globe className="h-4 w-4" />
                                    </Button>
                                    <Button variant="outline" size="icon" onClick={handleAddComment}>
                                        <MessageSquare className="h-4 w-4" />
                                    </Button>
                                    <Button variant="outline" size="icon" onClick={handleSpeech}>
                                        <Speech className="h-4 w-4" />
                                    </Button>
                                    {Object.entries(colorMap).map(([colorId, colorClass]) => (
                                        <Button
                                            key={colorId}
                                            className={`${colorClass} h-8 w-8 rounded-none border-0`}
                                            variant="ghost"
                                            onClick={() => handleColorSelect(colorId)}
                                        />
                                    ))}
                                </div>
                            )}
                        </PopoverContent>
                    </Popover>
                </div>
            </DialogContent>
        </Dialog>
    );
};

export default ChapterModal;

================
File: ui/ChapterSplitInput.tsx
================
import React, { useRef, useCallback, useState } from 'react';
import { Input } from '@/shared/ui/components/ui/input';
import { Button } from '@/shared/ui/components/ui/button';

interface ChapterSplitInputProps {
    value: number;
    onChange: (value: number) => void;
    onProcessBook?: () => void;
}

export const ChapterSplitInput: React.FC<ChapterSplitInputProps> = ({ value, onChange }) => {
    const [inputValue, setInputValue] = useState(value.toString());

    // Обработчик изменения значения в поле ввода
    const handleInputChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
        setInputValue(e.target.value);
    }, []);

    // Обработчик подтверждения изменения (при потере фокуса или нажатии Enter)
    const handleConfirmChange = useCallback(() => {
        const newValue = parseInt(inputValue, 10);
        if (!isNaN(newValue) && newValue > 0) {
            onChange(newValue);
        } else {
            // Если введено некорректное значение, возвращаем предыдущее
            setInputValue(value.toString());
        }
    }, [inputValue, onChange, value]);

    // Обработчик нажатия клавиши Enter
    const handleKeyDown = useCallback(
        (e: React.KeyboardEvent<HTMLInputElement>) => {
            if (e.key === 'Enter') {
                handleConfirmChange();
            }
        },
        [handleConfirmChange]
    );

    return (
        <div className="my-4 flex items-center">
            <label htmlFor="chapterSplitLimit" className="mr-2 text-sm font-medium text-gray-700">
                Лимит символов для разделения главы:
            </label>
            <Input
                type="text"
                id="chapterSplitLimit"
                value={inputValue}
                onChange={handleInputChange}
                onBlur={handleConfirmChange}
                onKeyDown={handleKeyDown}
                className="w-32 mr-2"
            />
        </div>
    );
};

================
File: ui/FileUploader.tsx
================
import React from 'react';
import { useDropzone, DropzoneOptions } from 'react-dropzone';
import { Card, CardContent, CardHeader, CardTitle } from '@/shared/ui/components/ui/card';
import { Upload, AlertCircle, FileText } from 'lucide-react';
import { cn } from '@/shared/lib/utils';

interface FileUploaderProps {
    onFileSelect: (file: File) => void;
    loading?: boolean;
    error?: string;
    title: string;
    acceptedFileTypes: Record<string, string[]>;
    maxFiles?: number;
    maxSize?: number;
    icon?: React.ReactNode;
    dragActiveText?: string;
    dragInactiveText?: string;
    loadingText?: string;
    className?: string;
}

export const FileUploader: React.FC<FileUploaderProps> = ({
    onFileSelect,
    loading,
    error,
    title,
    acceptedFileTypes,
    maxFiles = 1,
    maxSize,
    icon = <Upload className="mx-auto h-12 w-12 text-gray-400" />,
    dragActiveText = 'Отпустите файл здесь...',
    dragInactiveText = 'Перетащите файл сюда или кликните для выбора',
    loadingText = 'Загрузка и обработка файла...',
    className,
}) => {
    const [selectedFile, setSelectedFile] = React.useState<File | null>(null);

    const dropzoneOptions: DropzoneOptions = {
        onDrop: (acceptedFiles) => {
            const file = acceptedFiles[0];
            if (file) {
                setSelectedFile(file);
                onFileSelect(file);
            }
        },
        accept: acceptedFileTypes,
        multiple: maxFiles > 1,
        maxFiles,
        maxSize,
    };

    const { getRootProps, getInputProps, isDragActive } = useDropzone(dropzoneOptions);

    // Extract accepted file extensions
    const acceptedExtensions = Object.values(acceptedFileTypes).flat().join(', ');


    return (
        <Card className={cn('mb-4 relative', className)}>
            <CardHeader>
                <div className="flex justify-between items-center">
                    <CardTitle className="text-2xl font-bold">{title}</CardTitle>
                    <span className="text-sm ">Accepted: {acceptedExtensions}</span>
                </div>
            </CardHeader>
            <CardContent>
                <div
                    {...getRootProps()}
                    className={` border-2 border-dashed rounded-lg p-6 text-center transition-colors duration-300 ease-in-out cursor-pointer ${
                        isDragActive
                            ? 'border-blue-500 bg-blue-50'
                            : selectedFile
                            ? 'border-green-500 bg-green-50'
                            : 'border-gray-300 hover:border-gray-400'
                    }`}
                >
                    <input {...getInputProps()} />
                    {selectedFile ? (
                        <div className="flex items-center justify-center w-[400px]">
                            <FileText className="h-8 w-8 text-green-600" />
                            <p className="ml-2 text-green-600">{selectedFile.name}</p>
                        </div>
                    ) : (
                        <>
                            {icon}
                            <p className="mt-2 text-sm text-gray-600 w-[400px] text-center">{isDragActive ? dragActiveText : dragInactiveText}</p>
                        </>
                    )}
                </div>
                {loading && <p className="text-blue-500 mt-6 absolute right-1/4 -bottom-8">{loadingText}</p>}
                {error && error !== 'No file selected' && (
                    <div className="flex items-center text-red-500 mt-4">
                        <AlertCircle className="mr-2" />
                        <span>{error}</span>
                    </div>
                )}
            </CardContent>
        </Card>
    );
};

================
File: ui/Reader.tsx
================
import React, { useState, useCallback, useEffect } from 'react';
import ePub, { Book } from 'epubjs';
import { ChapterList } from './ChapterList';
import { FileUploader } from './FileUploader';
import { ChapterSplitInput } from './ChapterSplitInput';
import { processBook } from '../model/utils';
import { Chapter, HighlightAndNote } from '../model/types';
import { saveBookToLocalStorage, loadBookFromLocalStorage } from '../model/utils';
import { Select, SelectContent, SelectGroup, SelectItem, SelectLabel, SelectTrigger, SelectValue } from '@/shared/ui/components/ui/select';
import { Input } from '@/shared/ui/components/ui/input';
import TextToSpeech from './TextToSpeech';
import { FileJson2 } from 'lucide-react';

const Reader: React.FC = () => {
    const [book, setBook] = useState<Book | null>(null);
    const [chapters, setChapters] = useState<Chapter[]>([]);
    const [loading, setLoading] = useState<boolean>(false);
    const [error, setError] = useState<string>('');
    const [chapterSplitLimit, setChapterSplitLimit] = useState<number>(() => {
        const saved = localStorage.getItem('chapterSplitLimit');
        return saved ? parseInt(saved, 10) : 30000;
    });
    const [selectedReader, setSelectedReader] = useState('aquile');

    useEffect(() => {
        const loadSavedBook = async () => {
            const { book: savedBook, chapters: savedChapters } = await loadBookFromLocalStorage();
            if (savedBook && savedChapters.length > 0) {
                setBook(savedBook);
                setChapters(savedChapters);
            }
        };

        loadSavedBook();
    }, []);

    useEffect(() => {
        if (book && chapters.length > 0) {
            saveBookToLocalStorage(book, chapters);
        }
    }, [book, chapters]);

    const handleFile = useCallback(
        async (file: File) => {
            setLoading(true);
            setError('');
            try {
                const reader = new FileReader();
                reader.onload = async (e: ProgressEvent<FileReader>) => {
                    if (e.target && e.target.result) {
                        const bookData = e.target.result;
                        const newBook = ePub(bookData as ArrayBuffer);
                        setBook(newBook);
                        const processedChapters = await processBook(newBook, chapterSplitLimit);

                        
                        setChapters(processedChapters);
                        saveBookToLocalStorage(newBook, processedChapters);
                    }
                };
                reader.readAsArrayBuffer(file);
            } catch (err) {
                setError(`Ошибка при загрузке файла: ${(err as Error).message}`);
            } finally {
                setLoading(false);
            }
        },
        [chapterSplitLimit]
    );


    // Функция для обработки изменения лимита разделения глав
    const handleChapterSplitLimitChange = useCallback(
        async (newLimit: number) => {
            // Проверяем, что новый лимит отличается от текущего
            if (newLimit !== chapterSplitLimit) {
                setChapterSplitLimit(newLimit);
                localStorage.setItem('chapterSplitLimit', newLimit.toString());

                // Если книга загружена, пересчитываем главы
                if (book) {
                    setLoading(true);
                    try {
                        const processedChapters = await processBook(book, newLimit);
                        setChapters(processedChapters);
                        saveBookToLocalStorage(book, processedChapters);
                    } catch (err) {
                        setError(`Ошибка при обработке книги: ${(err as Error).message}`);
                    } finally {
                        setLoading(false);
                    }
                }
            }
        },
        [book, chapterSplitLimit]
    );

    const normalizeChapterTitle = (title: string): string => {
        const parts = title.split('»');
        if (parts.length > 1) {
            return parts[parts.length - 1].trim();
        }
        return title.trim();
    };

    const handleNotesFile = useCallback(async (file: File) => {
        try {
            const text = await file.text();
            const notesData = JSON.parse(text);

            // Парсим заметки и отфильтровываем те, которые не удалены
            const notes: HighlightAndNote[] = notesData.$values.filter((note: HighlightAndNote) => !note.IsDeleted);

            const notesMap: Record<string, HighlightAndNote[]> = {};
            notes.forEach((note) => {
                const chapterTitle = normalizeChapterTitle(note.SelectionTocLocation);
                if (!notesMap[chapterTitle]) {
                    notesMap[chapterTitle] = [];
                }
                notesMap[chapterTitle].push(note);
            });

            console.log(notesMap);

            // Обновляем главы с отфильтрованными заметками
            setChapters((prevChapters) =>
                prevChapters.map((chapter) => ({
                    ...chapter,
                    notes: notesMap[normalizeChapterTitle(chapter.title)] || [],
                }))
            );
        } catch (error) {
            console.error('Ошибка при загрузке файла:', error);
        }

        console.log('Updated chapters:', chapters);
    }, []);


    return (
        <div className="container mx-auto p-4">
            <div className="flex justify-between items-center gap-5">
                <FileUploader
                    onFileSelect={handleFile}
                    loading={loading}
                    error={error}
                    title="EPUB Reader"
                    acceptedFileTypes={{ 'application/epub+zip': ['.epub'] }}
                    loadingText="Загрузка и обработка EPUB файла..."
                    className="w-full h-[230px]"
                />
                <FileUploader
                    onFileSelect={handleNotesFile}
                    loading={loading}
                    error={error}
                    title="Highlighting notes"
                    acceptedFileTypes={{ 'application/json': ['.json'] }}
                    loadingText="Загрузка и обработка файла заметок..."
                    icon={<FileJson2 className="mx-auto h-12 w-12 text-gray-400" />}
                    className="w-full h-[230px]"
                />
            </div>

            <TextToSpeech />
            <ChapterSplitInput value={chapterSplitLimit} onChange={handleChapterSplitLimitChange} />
            <h3 className="mb-5">Exporting Reader</h3>
            <Select value={selectedReader} onValueChange={setSelectedReader}>
                <SelectTrigger className="w-[180px]">
                    <SelectValue />
                </SelectTrigger>
                <SelectContent>
                    <SelectGroup>
                        <SelectItem value="aquile">Aquile Reader</SelectItem>
                        <SelectItem value="pocketbook">PocketBook</SelectItem>
                    </SelectGroup>
                </SelectContent>
            </Select>

            <ChapterList chapters={chapters} />
        </div>
    );
};

export default Reader;

================
File: ui/TextToSpeech.tsx
================
import { useState, useEffect, useRef } from 'react';
import { Button } from '@/shared/ui/components/ui/button';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/shared/ui/components/ui/select';
import { Slider } from '@/shared/ui/components/ui/slider';
import { useDispatch } from 'react-redux';
import { useAppSelector } from '@/app/providers/config/store';

const TextToSpeech = () => {
    const dispatch = useDispatch();
    const text = useAppSelector((state) => state.textToSpeech.text);
    const [voices, setVoices] = useState<SpeechSynthesisVoice[]>([]);
    const [selectedVoice, setSelectedVoice] = useState<SpeechSynthesisVoice | null>(null);
    const [rate, setRate] = useState(6);
    const [isSpeaking, setIsSpeaking] = useState(false);
    const [isPaused, setIsPaused] = useState(false);
    const [currentSentence, setCurrentSentence] = useState(0);
    const synthRef = useRef<SpeechSynthesis>(window.speechSynthesis);
    const utteranceRef = useRef<SpeechSynthesisUtterance | null>(null);

    // set voices by default
    useEffect(() => {
        const updateVoices = () => {
            const availableVoices = synthRef.current.getVoices();
            setVoices(availableVoices);
            const pavelVoice = availableVoices.find((voice) => voice.name === 'Microsoft Pavel - Russian (Russia)');
            if (pavelVoice) {
                setSelectedVoice(pavelVoice);
            }
        };
        updateVoices();
        if (speechSynthesis.onvoiceschanged !== undefined) {
            speechSynthesis.onvoiceschanged = updateVoices;
        }
    }, []);

    useEffect(() => {
        if (text) {
            handleSpeak();
        }
    }, [text]);

    const sentences = text.match(/[^.!?]+[.!?]+/g) || [text];

    const handleSpeak = () => {
        if (synthRef.current.speaking) {
            synthRef.current.cancel();
        }
        if (text !== '') {
            utteranceRef.current = new SpeechSynthesisUtterance(text);
            if (selectedVoice) {
                utteranceRef.current.voice = selectedVoice;
            }
            utteranceRef.current.rate = rate;
            utteranceRef.current.onstart = () => setIsSpeaking(true);
            utteranceRef.current.onend = () => {
                setIsSpeaking(false);
                setCurrentSentence(0);
            };
            utteranceRef.current.onboundary = (event: SpeechSynthesisEvent) => {
                const sentenceIndex = sentences.findIndex((sentence, index) => {
                    const start = sentences.slice(0, index).join('').length;
                    const end = start + sentence.length;
                    return event.charIndex >= start && event.charIndex < end;
                });
                if (sentenceIndex !== -1) {
                    setCurrentSentence(sentenceIndex);
                }
            };
            utteranceRef.current.onerror = (event: SpeechSynthesisErrorEvent) => {
                console.error('SpeechSynthesisUtterance error', event);
                setIsSpeaking(false);
                setCurrentSentence(0);
            };
            synthRef.current.speak(utteranceRef.current);
        }
    };

    const handlePauseResume = () => {
        if (isPaused) {
            synthRef.current.resume();
            setIsPaused(false);
        } else {
            synthRef.current.pause();
            setIsPaused(true);
        }
    };

    const handleStop = () => {
        synthRef.current.cancel();
        setIsSpeaking(false);
        setIsPaused(false);
        setCurrentSentence(0);
    };

    const highlightText = () => {
        return sentences.map((sentence, index) => (
            <span key={index} className={index === currentSentence ? 'bg-cyan-900' : ''}>
                {sentence}
            </span>
        ));
    };

    return (
        <div className="w-full ">
            <div className="p-6">
                <p className="mb-4 p-2 border rounded">{isSpeaking ? highlightText() : text}</p>
                <Select
                    value={selectedVoice ? selectedVoice.name : ''}
                    onValueChange={(value) => setSelectedVoice(voices.find((voice) => voice.name === value) || null)}
                >
                    <SelectTrigger className="w-full mb-4">
                        <SelectValue placeholder="Выберите голос" />
                    </SelectTrigger>
                    <SelectContent>
                        {voices.map((voice) => (
                            <SelectItem key={voice.name} value={voice.name}>
                                {voice.name} ({voice.lang})
                            </SelectItem>
                        ))}
                    </SelectContent>
                </Select>
                <div className="mb-4">
                    <label className="block mb-2">Скорость речи: {rate.toFixed(1)}x</label>
                    <Slider min={0.1} max={10} step={0.1} value={[rate]} onValueChange={(values) => setRate(values[0])} className="w-full" />
                </div>
                <div className="flex space-x-2">
                    <Button onClick={handleSpeak} disabled={isSpeaking && !isPaused}>
                        {isSpeaking ? 'Перезапустить' : 'Озвучить'}
                    </Button>
                    <Button variant="secondary" onClick={handlePauseResume} disabled={!isSpeaking}>
                        {isPaused ? 'Возобновить' : 'Пауза'}
                    </Button>
                    <Button variant="destructive" onClick={handleStop} disabled={!isSpeaking && !isPaused}>
                        Стоп
                    </Button>
                </div>
            </div>
        </div>
    );
};

export default TextToSpeech;
